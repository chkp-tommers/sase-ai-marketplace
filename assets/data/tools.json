[
  {
    "id": "peekaboo-mcp",
    "name": "Peekaboo",
    "description": "A macOS-only MCP server that enables AI agents to capture screenshots of applications, or the entire system, with optional visual question answering through local or remote AI models.",
    "longDescription": "Peekaboo is a macOS-only MCP server that enables AI agents to capture screenshots of applications, or the entire system, with optional visual question answering through local or remote AI models. Without screenshots, agents debug blind—Peekaboo gives them eyes.",
    "type": "mcp",
    "category": "automation",
    "platforms": ["windsurf", "cursor", "claude"],
    "featured": true,
    "command": "npx",
    "args": ["@peekaboo/mcp-server"],
    "env": {},
    "requirements": {
      "os": "macOS",
      "node": ">=18.0.0",
      "dependencies": ["sharp", "screenshot-desktop"]
    },
    "installation": {
      "windsurf": "Add to .windsurf/mcp_config.json",
      "cursor": "Add to cursor settings → Features → MCP",
      "claude": "Configure in MCP settings"
    },
    "installationSteps": [
      "Open Cursor Settings",
      "Navigate to Cursor Settings → Features → MCP",
      "Click the \"+ Add New MCP Server\" button",
      "Configure the Server",
      "Name: Give your server a nickname",
      "Type: Select the transport type (stdio or sse)",
      "Command/URL: Enter either: For stdio servers: A valid shell command to run the server",
      "For sse servers: The URL of the SSE endpoint"
    ],
    "exampleConfig": {
      "stdio": {
        "command": "node",
        "args": ["/req-quickstart/peekaboo-server.js"]
      },
      "sse": {
        "url": "http://localhost:8080/sse"
      }
    },
    "features": [
      "Screenshot capture of entire system or specific applications",
      "Visual question answering through AI models",
      "Local or remote AI model integration",
      "Built specifically for macOS",
      "Seamless integration with MCP-compatible tools"
    ],
    "github": "https://github.com/peekaboo-ai/peekaboo-mcp",
    "readme": "# Peekaboo MCP\n\nA macOS-only MCP server for AI-powered screenshot analysis.\n\n## Installation\n\n```bash\nnpm install -g @peekaboo/mcp-server\n```\n\n## Usage\n\nConfigure in your MCP settings to enable visual AI capabilities."
  },
  {
    "id": "typescript-expert-prompt",
    "name": "TypeScript Expert",
    "description": "You are an expert in TypeScript, Node.js, Next.js App Router, React, and Modern UI/UX frameworks. Follow the user's requirements carefully & to the letter.",
    "type": "prompt",
    "category": "development",
    "platforms": ["cursor", "copilot", "claude"],
    "featured": true,
    "content": "You are an expert in TypeScript, Node.js, Next.js App Router, React, and Modern UI/UX frameworks (e.g., TailwindCSS, Shadcn, Radix). You are thoughtful, give nuanced answers, and are brilliant at reasoning. You carefully provide accurate, factual, thoughtful answers, and are a genius at reasoning.\n\n- Follow the user's requirements carefully & to the letter.\n- First think step-by-step - describe your plan for what to build in pseudocode, written out in great detail.\n- Confirm, then write code!\n- Always write correct, best practice, DRY principle (Don't Repeat Yourself), bug free, fully functional and working code also it should be aligned to listed rules down below at Code Implementation Guidelines.\n- Focus on easy and readability code, over being performant.\n- Fully implement all requested functionality.\n- Leave NO todo's, placeholders or missing pieces.\n- Ensure code is complete! Verify thoroughly finalised.\n- Include all required imports, and ensure proper naming or key components.\n- Be concise Minimize any other prose.\n- If you think there might not be a correct answer, you say so, instead of guessing.\n- If you do not know the answer, say so, instead of guessing.\n\n### Coding Environment\nThe user asks questions about the following coding languages:\n- ReactJS\n- NextJS\n- JavaScript\n- TypeScript\n- TailwindCSS\n- HTML\n- CSS\n\n### Code Implementation Guidelines\nFollow these rules when you write code:\n- Use early returns whenever possible to make the code more readable.\n- Always use Tailwind classes for styling HTML elements; avoid using CSS or tags.\n- Use 'class:' instead of the tertiary operator in class tags whenever possible.\n- Use descriptive variable and function/const names. Also, event functions should be named with a 'handle' prefix, like 'handleClick' for onClick and 'handleKeyDown' for onKeyDown.\n- Implement error handling and edge cases early.",
    "tags": [
      "TypeScript",
      "React",
      "Next.js",
      "TailwindCSS",
      "shadcn",
      "radix"
    ],
    "author": "CodeRabbit",
    "detailedDescription": "A comprehensive TypeScript development prompt that guides AI assistants to provide expert-level code reviews, architectural advice, and implementation guidance. Focuses on modern React/Next.js development with emphasis on best practices, clean code, and proper TypeScript usage.",
    "uses": 12450,
    "rating": 4.9
  },
  {
    "id": "frontend-developer-chatmode",
    "name": "Front-End Developer",
    "description": "Specialized AI assistant configuration for front-end development with modern frameworks and best practices",
    "type": "chatmode",
    "category": "development",
    "platforms": ["windsurf", "cursor", "claude"],
    "featured": true,
    "systemPrompt": "You are a Senior Front-End Developer and an Expert in ReactJS, NextJS, and Modern UI/UX frameworks (e.g., TailwindCSS, Shadcn, Radix). You are thoughtful, give nuanced answers, and are brilliant at reasoning. You carefully provide accurate, factual, thoughtful answers, and are a genius at reasoning.\n\n- Follow the user's requirements carefully & to the letter.\n- First think step-by-step - describe your plan for what to build in pseudocode, written out in great detail.\n- Confirm, then write code!\n- Always write correct, best practice, DRY principle (Don't Repeat Yourself), bug free, fully functional and working code also it should be aligned to listed rules down below at Code Implementation Guidelines.\n- Focus on easy and readability code, over being performant.\n- Fully implement all requested functionality.\n- Leave NO todo's, placeholders or missing pieces.\n- Ensure code is complete! Verify thoroughly finalised.\n- Include all required imports, and ensure proper naming or key components.\n- Be concise Minimize any other prose.\n- If you think there might not be a correct answer, you say so, instead of guessing.\n- If you do not know the answer, say so, instead of guessing.\n\n### Coding Environment\nThe user asks questions about the following coding languages:\n- ReactJS\n- NextJS\n- JavaScript \n- TypeScript\n- TailwindCSS\n- HTML\n- CSS\n\n### Code Implementation Guidelines\nFollow these rules when you write code:\n- Use early returns whenever possible to make the code more readable.\n- Always use Tailwind classes for styling HTML elements; avoid using CSS or tags.\n- Use 'class:' instead of the tertiary operator in class tags whenever possible.\n- Use descriptive variable and function/const names. Also, event functions should be named with a 'handle' prefix, like 'handleClick' for onClick and 'handleKeyDown' for onKeyDown.\n- Implement error handling and edge cases early.",
    "temperature": 0.3,
    "maxTokens": 4000,
    "tools": ["react", "nextjs", "tailwindcss", "typescript"],
    "tags": ["React", "Next.js", "TailwindCSS", "UI/UX", "frontend"],
    "author": "Frontend Guild",
    "detailedDescription": "A specialized chat mode configuration that transforms your AI assistant into an expert front-end developer. Focuses on React, Next.js, and modern UI frameworks with emphasis on clean code, best practices, and comprehensive implementation.",
    "uses": 8750,
    "rating": 4.8
  },
  {
    "id": "filesystem-mcp",
    "name": "Filesystem MCP",
    "description": "File system operations MCP server for reading, writing, and managing files",
    "type": "mcp",
    "category": "development",
    "platforms": ["windsurf", "cursor", "claude"],
    "featured": false,
    "command": "npx",
    "args": ["@filesystem/mcp"],
    "env": {
      "ALLOWED_PATHS": "/workspace"
    }
  },
  {
    "id": "git-mcp",
    "name": "Git MCP",
    "description": "Git operations MCP server for version control management",
    "type": "mcp",
    "category": "development",
    "platforms": ["windsurf", "cursor", "claude"],
    "featured": true,
    "command": "git-mcp",
    "args": [],
    "env": {}
  },
  {
    "id": "code-review-prompt",
    "name": "Code Review Assistant",
    "description": "Comprehensive code review prompt with security and performance focus",
    "type": "prompt",
    "category": "development",
    "platforms": ["cursor", "copilot", "claude"],
    "featured": true,
    "content": "# Code Review Assistant\n\nYou are an expert code reviewer with deep knowledge of security, performance, and best practices.\n\n## Your Role\n- Review code for bugs, security vulnerabilities, and performance issues\n- Suggest improvements and alternatives\n- Check for code style and convention adherence\n- Ensure proper error handling and edge cases\n\n## Review Checklist\n1. **Security**: SQL injection, XSS, authentication, authorization\n2. **Performance**: Algorithms, database queries, memory usage\n3. **Maintainability**: Code clarity, documentation, modularity\n4. **Testing**: Unit tests, edge cases, error scenarios\n5. **Standards**: Coding conventions, naming, structure\n\n## Output Format\nProvide feedback in this structure:\n- **Summary**: Overall assessment\n- **Critical Issues**: Security/performance problems\n- **Suggestions**: Improvements and alternatives\n- **Positives**: What's done well\n\nBe constructive and educational in your feedback."
  },
  {
    "id": "api-design-prompt",
    "name": "API Design Expert",
    "description": "REST API design and documentation specialist prompt",
    "type": "prompt",
    "category": "architecture",
    "platforms": ["cursor", "copilot", "claude"],
    "featured": false,
    "content": "# API Design Expert\n\nYou are an expert in REST API design, following industry best practices and standards.\n\n## Your Expertise\n- RESTful API design patterns\n- OpenAPI/Swagger documentation\n- Authentication and authorization\n- Error handling and status codes\n- API versioning strategies\n- Performance optimization\n\n## Design Principles\n1. **Consistency**: Uniform naming and patterns\n2. **Clarity**: Self-documenting endpoints\n3. **Security**: Proper authentication/authorization\n4. **Performance**: Efficient data transfer\n5. **Maintainability**: Versioning and backwards compatibility\n\nProvide detailed API specifications with examples."
  },
  {
    "id": "database-optimization-prompt",
    "name": "Database Optimization Expert",
    "description": "Database performance and optimization specialist",
    "type": "prompt",
    "category": "database",
    "platforms": ["cursor", "copilot", "claude"],
    "featured": false,
    "content": "# Database Optimization Expert\n\nSpecialize in database performance tuning, query optimization, and schema design.\n\n## Focus Areas\n- Query optimization and indexing\n- Schema design and normalization\n- Performance monitoring and analysis\n- Scaling strategies (horizontal/vertical)\n- Caching implementations\n\n## Analysis Framework\n1. **Query Performance**: Execution plans, indexing\n2. **Schema Design**: Normalization, relationships\n3. **Scalability**: Partitioning, replication\n4. **Monitoring**: Metrics, alerting\n\nProvide specific, actionable recommendations."
  },
  {
    "id": "api-architect",
    "name": "API Architect",
    "description": "Chat mode for designing and documenting RESTful APIs",
    "type": "chatmode",
    "category": "architecture",
    "platforms": ["windsurf", "cursor", "claude"],
    "featured": true,
    "systemPrompt": "You are an expert API architect specializing in RESTful API design, microservices architecture, and API documentation. You help design scalable, maintainable APIs following industry best practices.\n\n## Your Expertise:\n- RESTful API design patterns\n- OpenAPI/Swagger specification\n- Authentication & authorization (OAuth, JWT)\n- API versioning strategies\n- Error handling & status codes\n- Rate limiting & caching\n- Microservices architecture\n- API security best practices\n\n## Design Process:\n1. Understand requirements and use cases\n2. Design resource hierarchy and endpoints\n3. Define request/response schemas\n4. Specify authentication and authorization\n5. Document with OpenAPI specification\n6. Plan versioning and evolution strategy\n\nAlways provide concrete examples and follow REST principles."
  },
  {
    "id": "security-auditor",
    "name": "Security Auditor",
    "description": "Security-focused code review and vulnerability assessment",
    "type": "chatmode",
    "category": "security",
    "platforms": ["windsurf", "cursor", "claude"],
    "featured": false,
    "systemPrompt": "You are a cybersecurity expert specializing in application security, code review, and vulnerability assessment.\n\n## Security Focus Areas:\n- Input validation and sanitization\n- Authentication and authorization flaws\n- SQL injection and NoSQL injection\n- Cross-site scripting (XSS)\n- Cross-site request forgery (CSRF)\n- Insecure direct object references\n- Security misconfigurations\n- Cryptographic vulnerabilities\n- Business logic flaws\n\n## Methodology:\n1. Analyze code for common vulnerabilities\n2. Check for proper input validation\n3. Review authentication/authorization logic\n4. Assess data handling practices\n5. Evaluate cryptographic implementations\n6. Provide remediation recommendations\n\nPrioritize findings by severity and exploitability."
  },
  {
    "id": "performance-optimizer",
    "name": "Performance Optimizer",
    "description": "Application performance analysis and optimization specialist",
    "type": "chatmode",
    "category": "performance",
    "platforms": ["windsurf", "cursor", "claude"],
    "featured": false,
    "systemPrompt": "You are a performance optimization expert specializing in application performance, scalability, and efficiency.\n\n## Optimization Areas:\n- Algorithm complexity analysis\n- Database query optimization\n- Memory management\n- Caching strategies\n- Load balancing\n- CDN implementation\n- Concurrent programming\n- Resource utilization\n\n## Analysis Process:\n1. Identify performance bottlenecks\n2. Analyze algorithmic complexity\n3. Review database queries and indexing\n4. Assess caching opportunities\n5. Evaluate resource usage patterns\n6. Recommend optimization strategies\n\nProvide measurable improvements and benchmarking guidance."
  },
  {
    "id": "typescript-strict-rules",
    "name": "TypeScript Strict Configuration",
    "description": "Strict TypeScript configuration rules for type safety",
    "type": "rule",
    "category": "development",
    "platforms": ["cursor", "windsurf"],
    "featured": false,
    "content": "# TypeScript Strict Configuration\n\n## Compiler Options\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"noImplicitReturns\": true,\n    \"noImplicitThis\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true\n  }\n}\n```\n\n## Coding Standards\n- Use explicit type annotations\n- Handle null/undefined cases\n- Prefer interfaces over types for objects\n- Use strict function signatures\n- Enable all strict checks"
  },
  {
    "id": "react-best-practices",
    "name": "React Best Practices Rules",
    "description": "React development best practices and patterns",
    "type": "rule",
    "category": "frontend",
    "platforms": ["cursor", "windsurf"],
    "featured": false,
    "content": "# React Best Practices\n\n## Component Guidelines\n- Use functional components with hooks\n- Implement proper error boundaries\n- Optimize with React.memo when needed\n- Use useCallback and useMemo appropriately\n- Follow naming conventions (PascalCase)\n\n## State Management\n- Keep state close to where it's used\n- Use useReducer for complex state logic\n- Implement proper dependency arrays\n- Avoid unnecessary re-renders\n\n## Performance\n- Code splitting with React.lazy\n- Virtualization for large lists\n- Proper key props for lists\n- Minimize bundle size"
  },
  {
    "id": "api-security-rules",
    "name": "API Security Guidelines",
    "description": "Security rules and practices for API development",
    "type": "rule",
    "category": "security",
    "platforms": ["cursor", "windsurf"],
    "featured": true,
    "content": "# API Security Guidelines\n\n## Authentication & Authorization\n- Implement proper JWT token validation\n- Use HTTPS for all API endpoints\n- Implement rate limiting\n- Validate all input parameters\n- Use principle of least privilege\n\n## Data Protection\n- Encrypt sensitive data at rest\n- Use parameterized queries (prevent SQL injection)\n- Implement proper CORS policies\n- Log security events\n- Regular security audits\n\n## Error Handling\n- Don't expose sensitive information in errors\n- Use generic error messages\n- Log detailed errors server-side\n- Implement proper status codes"
  },
  {
    "id": "react-comprehensive-rules",
    "name": "React Comprehensive Development Rules",
    "description": "Complete React development guidelines with hooks, patterns, and best practices",
    "type": "rule",
    "category": "frontend",
    "platforms": ["cursor", "windsurf"],
    "featured": true,
    "content": "# React Comprehensive Development Rules\n\n## Component Design\n- Use functional components with hooks instead of class components\n- Use custom hooks for reusable logic\n- Use the Context API for state management when needed\n- Use proper prop validation with PropTypes or TypeScript\n- Use React.memo for performance optimization when necessary\n- Use fragments to avoid unnecessary wrapper divs\n\n## Hooks Best Practices\n- Use useState for simple local state\n- Use useReducer for complex state logic\n- Use useEffect for side effects, cleanup in return function\n- Use useContext to consume context values\n- Use useMemo to memoize expensive computations\n- Use useCallback to memoize functions passed as props\n- Use useRef for DOM references and mutable values\n- Create custom hooks to extract reusable component logic\n\n## State Management\n- Lift state up when needed to share state between components\n- Keep state as local as possible\n- Use immutable update patterns\n- Avoid deeply nested state objects\n- Consider using state management libraries (Redux, Zustand, Jotai) for complex apps\n\n## Performance Optimization\n- Use React.lazy() and Suspense for code splitting\n- Implement virtualization for long lists (react-window, react-virtualized)\n- Optimize re-renders with proper dependency arrays\n- Use production builds for deployment\n- Profile components with React DevTools\n- Avoid inline function definitions in render\n- Use key prop correctly in lists\n\n## Error Handling\n- Implement Error Boundaries for graceful error handling\n- Use try-catch in async operations\n- Provide meaningful error messages to users\n- Log errors for debugging\n- Handle loading and error states in components\n\n## Testing\n- Write unit tests with Jest and React Testing Library\n- Test user interactions, not implementation details\n- Use data-testid for reliable element selection\n- Mock external dependencies\n- Test accessibility with jest-axe\n\n## Code Organization\n- Organize components by feature, not by type\n- Keep components small and focused (single responsibility)\n- Extract complex logic into custom hooks\n- Use absolute imports with path aliases\n- Follow consistent file naming conventions",
    "tags": ["React", "hooks", "components", "state-management", "performance"],
    "author": "React Community",
    "detailedDescription": "Comprehensive React development rules covering modern patterns, hooks usage, performance optimization, and best practices for building scalable React applications."
  },
  {
    "id": "frontend-architecture-rules",
    "name": "Frontend Architecture Best Practices",
    "description": "General frontend development architecture patterns and principles",
    "type": "rule",
    "category": "frontend",
    "platforms": ["cursor", "windsurf"],
    "featured": true,
    "content": "# Frontend Architecture Best Practices\n\n## Architecture Principles\n- Separation of concerns (UI, logic, data)\n- Component-based architecture\n- Unidirectional data flow\n- Immutability and pure functions\n- Progressive enhancement\n- Mobile-first responsive design\n\n## Project Structure\n```\nsrc/\n├── components/      # Reusable UI components\n├── features/        # Feature-based modules\n├── hooks/          # Custom hooks\n├── services/       # API and external services\n├── utils/          # Helper functions\n├── styles/         # Global styles\n├── types/          # TypeScript types\n└── constants/      # App constants\n```\n\n## Component Design\n- Single Responsibility Principle\n- Composition over inheritance\n- Props interface documentation\n- Default props where appropriate\n- Proper prop types validation\n- Consistent naming conventions\n\n## State Management Patterns\n- Local state for component-specific data\n- Global state for app-wide data\n- Server state for API data (React Query, SWR)\n- URL state for navigation params\n- Form state management (React Hook Form, Formik)\n\n## Performance Strategies\n- Code splitting and lazy loading\n- Bundle size optimization\n- Image optimization (WebP, lazy loading)\n- Caching strategies\n- Service workers for offline support\n- Web Vitals monitoring (LCP, FID, CLS)\n\n## CSS Architecture\n- CSS Modules or CSS-in-JS\n- BEM naming convention\n- Utility-first with Tailwind CSS\n- Design system tokens\n- Responsive breakpoints\n- CSS custom properties\n\n## API Integration\n- Centralized API client\n- Request/response interceptors\n- Error handling middleware\n- Request cancellation\n- Retry logic\n- Type-safe API calls\n\n## Security Best Practices\n- Input sanitization\n- XSS prevention\n- CSRF protection\n- Content Security Policy\n- Secure authentication flow\n- Environment variables for secrets\n\n## Accessibility (a11y)\n- Semantic HTML\n- ARIA labels and roles\n- Keyboard navigation\n- Focus management\n- Screen reader support\n- Color contrast compliance\n\n## Testing Strategy\n- Unit tests for utilities\n- Integration tests for features\n- E2E tests for critical paths\n- Visual regression testing\n- Performance testing\n- Accessibility testing",
    "tags": ["frontend", "architecture", "performance", "accessibility", "security"],
    "author": "Frontend Masters",
    "detailedDescription": "Comprehensive frontend architecture guidelines covering project structure, component design, state management, performance optimization, and best practices for building modern web applications."
  },
  {
    "id": "backend-development-rules",
    "name": "Backend Development Best Practices",
    "description": "Comprehensive backend development patterns for scalable server applications",
    "type": "rule",
    "category": "backend",
    "platforms": ["cursor", "windsurf"],
    "featured": true,
    "content": "# Backend Development Best Practices\n\n## Architecture Patterns\n- **Clean Architecture**: Separate business logic from infrastructure\n- **Microservices**: When appropriate, design loosely coupled services\n- **API Gateway**: Centralize API management and routing\n- **Event-Driven**: Use message queues for async operations\n- **CQRS**: Separate read and write operations when beneficial\n\n## API Design Principles\n- **RESTful Standards**: Use proper HTTP methods and status codes\n- **Versioning**: Implement API versioning (URL or header-based)\n- **Documentation**: Use OpenAPI/Swagger for API documentation\n- **Consistency**: Uniform response formats and naming conventions\n- **Pagination**: Implement cursor or offset-based pagination\n- **Rate Limiting**: Protect APIs from abuse\n\n## Database Design\n- **Normalization**: Follow normal forms when appropriate\n- **Indexing**: Create indexes for frequently queried columns\n- **Migrations**: Version control database schema changes\n- **Connection Pooling**: Optimize database connections\n- **Query Optimization**: Use EXPLAIN to analyze queries\n- **Caching**: Implement Redis/Memcached for frequently accessed data\n\n## Authentication & Authorization\n- **JWT Tokens**: Stateless authentication with proper expiration\n- **OAuth 2.0**: For third-party integrations\n- **RBAC**: Role-based access control\n- **API Keys**: For service-to-service communication\n- **Session Management**: Secure session handling\n- **Password Security**: Bcrypt/Argon2 for hashing\n\n## Error Handling\n- **Consistent Error Format**: Standardized error responses\n- **Error Codes**: Machine-readable error identification\n- **Logging**: Structured logging with appropriate levels\n- **Monitoring**: Real-time error tracking (Sentry, DataDog)\n- **Graceful Degradation**: Fallback mechanisms\n\n## Performance Optimization\n- **Caching Strategies**: Multi-level caching (CDN, application, database)\n- **Async Processing**: Background jobs for heavy operations\n- **Database Optimization**: Query optimization, connection pooling\n- **Load Balancing**: Distribute traffic across instances\n- **Horizontal Scaling**: Design for scalability\n- **Resource Management**: Memory and CPU optimization\n\n## Security Best Practices\n- **Input Validation**: Validate all incoming data\n- **SQL Injection Prevention**: Use parameterized queries\n- **XSS Prevention**: Sanitize output data\n- **HTTPS Only**: Enforce SSL/TLS\n- **Security Headers**: HSTS, CSP, X-Frame-Options\n- **Dependency Scanning**: Regular security audits\n- **Secrets Management**: Use vault services\n\n## Testing Strategy\n- **Unit Tests**: Test individual functions/methods\n- **Integration Tests**: Test component interactions\n- **API Tests**: Test endpoints with various scenarios\n- **Load Tests**: Verify performance under stress\n- **Security Tests**: Penetration testing\n- **Contract Tests**: Ensure API compatibility\n\n## DevOps Practices\n- **CI/CD**: Automated testing and deployment\n- **Containerization**: Docker for consistency\n- **Orchestration**: Kubernetes for container management\n- **Infrastructure as Code**: Terraform/CloudFormation\n- **Monitoring**: APM tools (New Relic, AppDynamics)\n- **Logging**: Centralized logging (ELK stack)\n\n## Code Organization\n```\nsrc/\n├── controllers/    # Request handlers\n├── services/       # Business logic\n├── models/         # Data models\n├── repositories/   # Data access layer\n├── middleware/     # Custom middleware\n├── utils/          # Helper functions\n├── config/         # Configuration files\n└── tests/          # Test files\n```",
    "tags": ["backend", "api", "security", "performance", "architecture"],
    "author": "Backend Engineering Team",
    "detailedDescription": "Comprehensive backend development guidelines covering architecture patterns, API design, database management, security, performance optimization, and DevOps practices for building scalable server applications."
  },
  {
    "id": "nodejs-development-rules",
    "name": "Node.js Development Best Practices",
    "description": "Node.js specific patterns and best practices for server-side JavaScript",
    "type": "rule",
    "category": "backend",
    "platforms": ["cursor", "windsurf"],
    "featured": true,
    "content": "# Node.js Development Best Practices\n\n## Core Principles\n- **Asynchronous Programming**: Use async/await over callbacks\n- **Error-First Callbacks**: Follow Node.js convention\n- **Event-Driven Architecture**: Leverage EventEmitter\n- **Non-Blocking I/O**: Avoid synchronous operations\n- **Small Modules**: Create focused, reusable modules\n\n## Project Structure\n```\nproject/\n├── src/\n│   ├── controllers/\n│   ├── services/\n│   ├── models/\n│   ├── middleware/\n│   ├── routes/\n│   ├── utils/\n│   └── config/\n├── tests/\n├── scripts/\n└── package.json\n```\n\n## Express.js Best Practices\n- **Middleware Order**: Body parsers → custom middleware → routes → error handlers\n- **Router Organization**: Use Express Router for modular routes\n- **Error Handling**: Centralized error handling middleware\n- **Validation**: Use express-validator or Joi\n- **Security**: Helmet.js for security headers\n- **CORS**: Configure properly for production\n\n## Async Patterns\n```javascript\n// Good: async/await with proper error handling\nasync function processData(data) {\n  try {\n    const result = await someAsyncOperation(data);\n    return result;\n  } catch (error) {\n    logger.error('Processing failed:', error);\n    throw new AppError('Data processing failed', 500);\n  }\n}\n\n// Promise.all for parallel operations\nconst [user, posts] = await Promise.all([\n  getUserById(id),\n  getPostsByUserId(id)\n]);\n```\n\n## Error Handling\n- **Custom Error Classes**: Extend Error for app-specific errors\n- **Global Error Handler**: Catch unhandled errors\n- **Async Error Wrapper**: Wrap async route handlers\n- **Logging**: Use Winston or Pino for structured logging\n- **Process Events**: Handle uncaughtException and unhandledRejection\n\n## Performance Optimization\n- **Clustering**: Use PM2 or native cluster module\n- **Caching**: Implement Redis for session and data caching\n- **Database Pooling**: Connection pooling for databases\n- **Stream Processing**: Use streams for large data\n- **Compression**: Enable gzip compression\n- **Rate Limiting**: Protect against abuse\n\n## Security Practices\n- **Environment Variables**: Use dotenv for configuration\n- **Input Validation**: Validate all user inputs\n- **Authentication**: Implement JWT properly\n- **HTTPS**: Always use in production\n- **Dependencies**: Regular updates and audit\n- **SQL Injection**: Use parameterized queries\n\n## Database Integration\n- **ORM/ODM**: Use Sequelize, TypeORM, or Mongoose\n- **Migrations**: Version control schema changes\n- **Connection Management**: Proper pooling\n- **Transactions**: Use for data consistency\n- **Query Optimization**: Monitor and optimize slow queries\n\n## Testing\n- **Unit Tests**: Jest or Mocha for unit testing\n- **Integration Tests**: Supertest for API testing\n- **Test Coverage**: Aim for >80% coverage\n- **Mocking**: Mock external dependencies\n- **CI/CD**: Automated testing in pipeline\n\n## Production Considerations\n- **Process Manager**: Use PM2 for production\n- **Health Checks**: Implement health endpoints\n- **Graceful Shutdown**: Handle SIGTERM properly\n- **Memory Leaks**: Monitor and prevent\n- **Logging**: Structured, leveled logging\n- **Monitoring**: APM tools integration\n\n## Common Patterns\n```javascript\n// Repository Pattern\nclass UserRepository {\n  async findById(id) {\n    return await User.findByPk(id);\n  }\n  \n  async create(userData) {\n    return await User.create(userData);\n  }\n}\n\n// Service Layer\nclass UserService {\n  constructor(userRepository) {\n    this.userRepository = userRepository;\n  }\n  \n  async getUserProfile(userId) {\n    const user = await this.userRepository.findById(userId);\n    if (!user) {\n      throw new NotFoundError('User not found');\n    }\n    return this.formatUserProfile(user);\n  }\n}\n\n// Middleware Pattern\nconst authenticate = async (req, res, next) => {\n  try {\n    const token = req.headers.authorization?.split(' ')[1];\n    const decoded = await verifyToken(token);\n    req.user = decoded;\n    next();\n  } catch (error) {\n    next(new UnauthorizedError('Invalid token'));\n  }\n};\n```",
    "tags": ["nodejs", "express", "async", "performance", "security"],
    "author": "Node.js Foundation",
    "detailedDescription": "Comprehensive Node.js development guidelines covering async patterns, Express.js best practices, error handling, performance optimization, security, and production deployment strategies."
  },
  {
    "id": "mongodb-best-practices",
    "name": "MongoDB Database Best Practices",
    "description": "MongoDB design patterns, optimization, and best practices for NoSQL development",
    "type": "rule",
    "category": "database",
    "platforms": ["cursor", "windsurf"],
    "featured": true,
    "content": "# MongoDB Best Practices\n\n## Schema Design Principles\n- **Document Structure**: Design based on data access patterns\n- **Embedding vs Referencing**: Embed for 1:1 and 1:few, reference for 1:many\n- **Denormalization**: Optimize for read performance\n- **Schema Validation**: Use JSON Schema validation\n- **Avoid Large Documents**: Keep documents under 16MB\n\n## Data Modeling Patterns\n```javascript\n// Embedding Pattern (1:few)\n{\n  _id: ObjectId('...'),\n  name: 'John Doe',\n  addresses: [\n    { type: 'home', street: '123 Main St', city: 'Boston' },\n    { type: 'work', street: '456 Office Blvd', city: 'Cambridge' }\n  ]\n}\n\n// Reference Pattern (1:many)\n// User document\n{ _id: ObjectId('...'), name: 'John Doe' }\n// Order documents\n{ _id: ObjectId('...'), userId: ObjectId('...'), total: 99.99 }\n\n// Hybrid Pattern\n{\n  _id: ObjectId('...'),\n  name: 'Blog Post',\n  author: { id: ObjectId('...'), name: 'Jane Smith' }, // Denormalized\n  comments: [ // Embedded recent comments\n    { text: 'Great post!', date: ISODate('...') }\n  ],\n  commentCount: 150 // Counter for all comments\n}\n```\n\n## Indexing Strategies\n- **Single Field Index**: For simple queries\n- **Compound Index**: For queries on multiple fields\n- **Multikey Index**: For array fields\n- **Text Index**: For text search\n- **Geospatial Index**: For location queries\n- **TTL Index**: For automatic document expiration\n\n```javascript\n// Creating indexes\ndb.users.createIndex({ email: 1 }, { unique: true });\ndb.posts.createIndex({ userId: 1, createdAt: -1 });\ndb.products.createIndex({ name: 'text', description: 'text' });\ndb.events.createIndex({ expireAt: 1 }, { expireAfterSeconds: 0 });\n```\n\n## Query Optimization\n- **Use Projection**: Return only needed fields\n- **Limit Results**: Use limit() for pagination\n- **Use Covered Queries**: Query only indexed fields\n- **Avoid $where**: Use standard query operators\n- **Explain Plans**: Analyze query performance\n\n```javascript\n// Optimized query example\ndb.users.find(\n  { status: 'active', age: { $gte: 18 } },\n  { name: 1, email: 1, _id: 0 }\n).limit(20).hint({ status: 1, age: 1 });\n```\n\n## Aggregation Pipeline\n```javascript\n// Complex aggregation example\ndb.orders.aggregate([\n  { $match: { status: 'completed' } },\n  { $lookup: {\n      from: 'users',\n      localField: 'userId',\n      foreignField: '_id',\n      as: 'user'\n  }},\n  { $unwind: '$user' },\n  { $group: {\n      _id: '$user.country',\n      totalRevenue: { $sum: '$total' },\n      orderCount: { $sum: 1 }\n  }},\n  { $sort: { totalRevenue: -1 } },\n  { $limit: 10 }\n]);\n```\n\n## Performance Best Practices\n- **Connection Pooling**: Reuse database connections\n- **Batch Operations**: Use bulkWrite for multiple operations\n- **Read Preference**: Use secondary reads when appropriate\n- **Write Concern**: Balance durability and performance\n- **Sharding**: Horizontal scaling for large datasets\n\n## Security Considerations\n- **Authentication**: Enable auth in production\n- **Authorization**: Use role-based access control\n- **Encryption**: Enable TLS/SSL\n- **Field Encryption**: Client-side field encryption for sensitive data\n- **Auditing**: Enable audit logs\n\n## Mongoose Best Practices\n```javascript\n// Schema definition with validation\nconst userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    unique: true,\n    lowercase: true,\n    validate: [validator.isEmail, 'Invalid email']\n  },\n  age: {\n    type: Number,\n    min: [18, 'Must be at least 18'],\n    max: [120, 'Must be at most 120']\n  },\n  roles: [{\n    type: String,\n    enum: ['user', 'admin', 'moderator']\n  }]\n}, {\n  timestamps: true,\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n});\n\n// Virtual properties\nuserSchema.virtual('fullName').get(function() {\n  return `${this.firstName} ${this.lastName}`;\n});\n\n// Indexes\nuserSchema.index({ email: 1, createdAt: -1 });\n\n// Middleware\nuserSchema.pre('save', async function(next) {\n  if (this.isModified('password')) {\n    this.password = await bcrypt.hash(this.password, 10);\n  }\n  next();\n});\n```\n\n## Monitoring and Maintenance\n- **Performance Monitoring**: Use MongoDB Atlas or Ops Manager\n- **Slow Query Logs**: Enable and analyze\n- **Index Usage**: Monitor and remove unused indexes\n- **Storage**: Monitor disk usage and plan capacity\n- **Backups**: Regular automated backups\n- **Replica Sets**: High availability setup",
    "tags": ["mongodb", "nosql", "database", "mongoose", "performance"],
    "author": "MongoDB Inc.",
    "detailedDescription": "Comprehensive MongoDB guidelines covering schema design, indexing strategies, query optimization, aggregation pipelines, security, and Mongoose ODM best practices for building scalable NoSQL applications."
  },
  {
    "id": "golang-development-rules",
    "name": "Go (Golang) Development Best Practices",
    "description": "Go programming patterns, idioms, and best practices for backend development",
    "type": "rule",
    "category": "backend",
    "platforms": ["cursor", "windsurf"],
    "featured": true,
    "content": "# Go Development Best Practices\n\n## Go Principles\n- **Simplicity**: Prefer simple, clear code over clever solutions\n- **Composition**: Favor composition over inheritance\n- **Interfaces**: Define small, focused interfaces\n- **Concurrency**: Use goroutines and channels effectively\n- **Error Handling**: Explicit error handling, no exceptions\n\n## Project Structure\n```\nproject/\n├── cmd/\n│   └── server/\n│       └── main.go\n├── internal/\n│   ├── handlers/\n│   ├── services/\n│   ├── models/\n│   └── repository/\n├── pkg/\n│   └── utils/\n├── configs/\n├── scripts/\n├── go.mod\n└── go.sum\n```\n\n## Code Style\n- **Formatting**: Use `gofmt` and `goimports`\n- **Linting**: Use `golangci-lint`\n- **Naming**: Follow Go naming conventions\n- **Comments**: Write clear godoc comments\n- **Package Names**: Short, lowercase, no underscores\n\n## Error Handling\n```go\n// Custom error types\ntype ValidationError struct {\n    Field string\n    Message string\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation error: %s - %s\", e.Field, e.Message)\n}\n\n// Error wrapping\nif err != nil {\n    return fmt.Errorf(\"failed to process user: %w\", err)\n}\n\n// Error checking\nuser, err := getUserByID(id)\nif err != nil {\n    if errors.Is(err, ErrNotFound) {\n        return nil, status.Error(codes.NotFound, \"user not found\")\n    }\n    return nil, fmt.Errorf(\"get user: %w\", err)\n}\n```\n\n## Interfaces and Types\n```go\n// Small, focused interfaces\ntype Reader interface {\n    Read(ctx context.Context, id string) (*Entity, error)\n}\n\ntype Writer interface {\n    Write(ctx context.Context, entity *Entity) error\n}\n\n// Embed interfaces for composition\ntype Repository interface {\n    Reader\n    Writer\n}\n\n// Accept interfaces, return concrete types\nfunc NewService(repo Repository) *Service {\n    return &Service{repo: repo}\n}\n```\n\n## Concurrency Patterns\n```go\n// Goroutine with error handling\nerrCh := make(chan error, 1)\ngo func() {\n    errCh <- doSomeWork()\n}()\n\nselect {\ncase err := <-errCh:\n    if err != nil {\n        return fmt.Errorf(\"work failed: %w\", err)\n    }\ncase <-ctx.Done():\n    return ctx.Err()\n}\n\n// Worker pool pattern\ntype Job struct {\n    ID   int\n    Data string\n}\n\nfunc workerPool(jobs <-chan Job, results chan<- Result, workerCount int) {\n    var wg sync.WaitGroup\n    wg.Add(workerCount)\n    \n    for i := 0; i < workerCount; i++ {\n        go func() {\n            defer wg.Done()\n            for job := range jobs {\n                result := processJob(job)\n                results <- result\n            }\n        }()\n    }\n    \n    wg.Wait()\n    close(results)\n}\n```\n\n## HTTP Server\n```go\n// Using chi router\nfunc setupRoutes() chi.Router {\n    r := chi.NewRouter()\n    \n    // Middleware\n    r.Use(middleware.Logger)\n    r.Use(middleware.Recoverer)\n    r.Use(middleware.Timeout(60 * time.Second))\n    \n    // Routes\n    r.Route(\"/api/v1\", func(r chi.Router) {\n        r.Use(authMiddleware)\n        r.Get(\"/users/{id}\", handleGetUser)\n        r.Post(\"/users\", handleCreateUser)\n    })\n    \n    return r\n}\n\n// Handler with proper error handling\nfunc handleGetUser(w http.ResponseWriter, r *http.Request) {\n    ctx := r.Context()\n    userID := chi.URLParam(r, \"id\")\n    \n    user, err := userService.GetByID(ctx, userID)\n    if err != nil {\n        handleError(w, err)\n        return\n    }\n    \n    respond(w, http.StatusOK, user)\n}\n```\n\n## Database Patterns\n```go\n// Using database/sql\ntype UserRepository struct {\n    db *sql.DB\n}\n\nfunc (r *UserRepository) GetByID(ctx context.Context, id string) (*User, error) {\n    var user User\n    query := `SELECT id, name, email FROM users WHERE id = $1`\n    \n    err := r.db.QueryRowContext(ctx, query, id).Scan(\n        &user.ID, &user.Name, &user.Email,\n    )\n    if err == sql.ErrNoRows {\n        return nil, ErrNotFound\n    }\n    if err != nil {\n        return nil, fmt.Errorf(\"query user: %w\", err)\n    }\n    \n    return &user, nil\n}\n\n// Transaction handling\nfunc (r *UserRepository) CreateWithProfile(ctx context.Context, user *User, profile *Profile) error {\n    tx, err := r.db.BeginTx(ctx, nil)\n    if err != nil {\n        return fmt.Errorf(\"begin transaction: %w\", err)\n    }\n    defer tx.Rollback()\n    \n    if err := createUser(ctx, tx, user); err != nil {\n        return fmt.Errorf(\"create user: %w\", err)\n    }\n    \n    if err := createProfile(ctx, tx, profile); err != nil {\n        return fmt.Errorf(\"create profile: %w\", err)\n    }\n    \n    return tx.Commit()\n}\n```\n\n## Testing\n```go\n// Table-driven tests\nfunc TestValidateEmail(t *testing.T) {\n    tests := []struct {\n        name    string\n        email   string\n        wantErr bool\n    }{\n        {\"valid email\", \"test@example.com\", false},\n        {\"invalid email\", \"invalid\", true},\n        {\"empty email\", \"\", true},\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            err := ValidateEmail(tt.email)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"ValidateEmail() error = %v, wantErr %v\", err, tt.wantErr)\n            }\n        })\n    }\n}\n\n// Mocking interfaces\ntype mockRepository struct {\n    users map[string]*User\n}\n\nfunc (m *mockRepository) GetByID(ctx context.Context, id string) (*User, error) {\n    user, ok := m.users[id]\n    if !ok {\n        return nil, ErrNotFound\n    }\n    return user, nil\n}\n```\n\n## Performance Tips\n- **Profiling**: Use pprof for CPU and memory profiling\n- **Benchmarking**: Write benchmarks for critical paths\n- **Pooling**: Reuse objects with sync.Pool\n- **Buffering**: Use buffered channels appropriately\n- **Avoid Allocations**: Minimize allocations in hot paths",
    "tags": ["golang", "go", "concurrency", "backend", "performance"],
    "author": "Go Community",
    "detailedDescription": "Comprehensive Go development guidelines covering language idioms, project structure, error handling, concurrency patterns, HTTP servers, database integration, testing strategies, and performance optimization."
  },
{
  "id": "testing-best-practices",
  "name": "Testing Best Practices",
  "description": "Comprehensive testing strategies for all types of software testing",
  "type": "rule",
  "category": "testing",
  "platforms": ["cursor", "windsurf"],
  "featured": true,
  "content": "# Testing Best Practices\n\n## Testing Philosophy\n- **Test Pyramid**: Unit tests at base, integration in middle, E2E at top\n- **Test-Driven Development**: Write tests before implementation\n- **Behavior-Driven Development**: Focus on behavior, not implementation\n- **Continuous Testing**: Integrate testing into CI/CD pipeline\n- **Shift-Left Testing**: Test early and often\n\n## Unit Testing\n- **Isolation**: Test components in isolation\n- **Fast Execution**: Tests should run quickly\n- **Deterministic**: Same input always produces same output\n- **Single Responsibility**: One test per behavior\n- **Descriptive Names**: Test names should describe what they test\n\n```javascript\n// Good test example\ndescribe('UserService', () => {\n  describe('createUser', () => {\n    it('should create a user with valid data', async () => {\n      const userData = { name: 'John', email: 'john@example.com' };\n      const user = await userService.createUser(userData);\n      expect(user).toHaveProperty('id');\n      expect(user.name).toBe(userData.name);\n    });\n\n    it('should throw error for duplicate email', async () => {\n      const userData = { name: 'John', email: 'existing@example.com' };\n      await expect(userService.createUser(userData))\n        .rejects.toThrow('Email already exists');\n    });\n  });\n});\n```\n\n## Integration Testing\n- **Real Dependencies**: Test with actual databases, APIs\n- **Transaction Rollback**: Clean up after tests\n- **Test Data Management**: Use factories or fixtures\n- **API Contract Testing**: Verify API contracts\n- **Database Testing**: Test queries and transactions\n\n```javascript\n// Integration test example\ndescribe('POST /api/users', () => {\n  beforeEach(async () => {\n    await db.clean();\n  });\n\n  it('should create user and return 201', async () => {\n    const response = await request(app)\n      .post('/api/users')\n      .send({ name: 'John', email: 'john@example.com' })\n      .expect(201);\n\n    expect(response.body).toHaveProperty('id');\n    const user = await db.users.findById(response.body.id);\n    expect(user).toBeTruthy();\n  });\n});\n```\n\n## End-to-End Testing\n- **User Journeys**: Test complete user workflows\n- **Browser Automation**: Use tools like Playwright, Cypress\n- **Visual Testing**: Screenshot comparisons\n- **Performance Testing**: Measure load times\n- **Cross-Browser Testing**: Test on multiple browsers\n\n```javascript\n// E2E test example with Playwright\ntest('user can complete purchase', async ({ page }) => {\n  await page.goto('/products');\n  await page.click('[data-testid=\"product-1\"]');\n  await page.click('[data-testid=\"add-to-cart\"]');\n  await page.goto('/cart');\n  await page.click('[data-testid=\"checkout\"]');\n  await page.fill('[name=\"email\"]', 'test@example.com');\n  await page.fill('[name=\"card\"]', '4242424242424242');\n  await page.click('[data-testid=\"complete-order\"]');\n  await expect(page.locator('.success-message')).toBeVisible();\n});\n```\n\n## Test Organization\n- **AAA Pattern**: Arrange, Act, Assert\n- **Given-When-Then**: BDD style organization\n- **Test Fixtures**: Reusable test data\n- **Page Objects**: Encapsulate page interactions\n- **Helper Functions**: DRY test utilities\n\n## Mocking and Stubbing\n- **Mock External Services**: Don't call real APIs in tests\n- **Stub Time**: Control time-dependent behavior\n- **Spy on Functions**: Verify function calls\n- **Fake Implementations**: Lightweight test doubles\n\n```javascript\n// Mocking example\njest.mock('./emailService');\n\ntest('sends welcome email on signup', async () => {\n  const sendEmailSpy = jest.spyOn(emailService, 'send');\n  await userService.signup({ email: 'test@example.com' });\n  \n  expect(sendEmailSpy).toHaveBeenCalledWith(\n    expect.objectContaining({\n      to: 'test@example.com',\n      template: 'welcome'\n    })\n  );\n});\n```\n\n## Performance Testing\n- **Load Testing**: Test under expected load\n- **Stress Testing**: Find breaking points\n- **Spike Testing**: Test sudden load increases\n- **Endurance Testing**: Test sustained load\n- **Benchmark Testing**: Measure performance metrics\n\n## Security Testing\n- **Input Validation**: Test with malicious input\n- **Authentication Testing**: Verify auth mechanisms\n- **Authorization Testing**: Test access controls\n- **SQL Injection**: Test for injection vulnerabilities\n- **XSS Testing**: Test for script injection\n\n## Accessibility Testing\n- **Screen Reader Testing**: Test with assistive technology\n- **Keyboard Navigation**: Test without mouse\n- **Color Contrast**: Verify WCAG compliance\n- **ARIA Testing**: Verify proper ARIA usage\n- **Automated Tools**: Use axe-core, pa11y\n\n## Test Data Management\n- **Test Factories**: Generate test data programmatically\n- **Fixtures**: Static test data files\n- **Database Seeding**: Populate test databases\n- **Data Cleanup**: Reset between tests\n- **Anonymized Production Data**: Use sanitized real data\n\n## Continuous Integration\n- **Automated Test Runs**: Run tests on every commit\n- **Parallel Execution**: Speed up test suites\n- **Test Reports**: Generate coverage reports\n- **Flaky Test Detection**: Identify unreliable tests\n- **Test Environment**: Consistent test environment\n\n## Best Practices Summary\n- Write tests first (TDD)\n- Keep tests simple and focused\n- Use descriptive test names\n- Maintain test independence\n- Mock external dependencies\n- Use data-testid for E2E tests\n- Monitor test coverage\n- Fix flaky tests immediately\n- Review tests in code reviews\n- Keep tests fast",
  "tags": ["testing", "unit-testing", "integration-testing", "e2e", "tdd"],
  "author": "Testing Community",
  "detailedDescription": "Comprehensive testing guidelines covering unit testing, integration testing, E2E testing, performance testing, security testing, and test automation best practices."
},
{
  "id": "automation-cicd-rules",
  "name": "Automation & CI/CD Best Practices",
  "description": "Build automation, continuous integration, and deployment pipeline best practices",
  "type": "rule",
  "category": "devops",
  "platforms": ["cursor", "windsurf"],
  "featured": true,
  "content": "# Automation & CI/CD Best Practices\n\n## CI/CD Principles\n- **Automate Everything**: From build to deployment\n- **Fail Fast**: Catch issues early in the pipeline\n- **Reproducible Builds**: Same input = same output\n- **Progressive Deployment**: Deploy gradually\n- **Rollback Capability**: Quick recovery from failures\n\n## Pipeline Architecture\n```yaml\n# Example CI/CD Pipeline\nstages:\n  - build\n  - test\n  - security\n  - deploy\n  - monitor\n\nbuild:\n  stage: build\n  script:\n    - npm install\n    - npm run build\n  artifacts:\n    paths:\n      - dist/\n\ntest:\n  stage: test\n  parallel:\n    matrix:\n      - TEST_TYPE: [unit, integration, e2e]\n  script:\n    - npm run test:$TEST_TYPE\n```\n\n## Build Automation\n- **Dependency Management**: Lock file for reproducibility\n- **Build Caching**: Speed up builds\n- **Artifact Management**: Store build outputs\n- **Multi-Stage Builds**: Optimize Docker images\n- **Environment Variables**: Externalize configuration\n\n## Testing Automation\n- **Parallel Testing**: Run tests concurrently\n- **Test Selection**: Run only affected tests\n- **Coverage Gates**: Minimum coverage requirements\n- **Performance Benchmarks**: Track performance\n- **Visual Regression**: Screenshot comparisons\n\n## Code Quality Gates\n- **Linting**: Enforce code standards\n- **Type Checking**: TypeScript strict mode\n- **Security Scanning**: Dependency vulnerabilities\n- **Code Coverage**: Minimum thresholds\n- **Complexity Analysis**: Cyclomatic complexity\n\n```javascript\n// Quality gate configuration\nmodule.exports = {\n  coverage: {\n    statements: 80,\n    branches: 75,\n    functions: 80,\n    lines: 80\n  },\n  complexity: {\n    max: 10\n  },\n  duplication: {\n    threshold: 3\n  }\n};\n```\n\n## Deployment Strategies\n- **Blue-Green Deployment**: Zero-downtime deployments\n- **Canary Releases**: Gradual rollout\n- **Feature Flags**: Toggle features without deployment\n- **Rolling Updates**: Update instances gradually\n- **Rollback Plan**: Quick recovery strategy\n\n## Infrastructure as Code\n- **Version Control**: Track infrastructure changes\n- **Terraform/CloudFormation**: Define infrastructure\n- **Immutable Infrastructure**: Replace, don't modify\n- **Environment Parity**: Dev/staging/prod consistency\n- **Secret Management**: Secure credential handling\n\n```hcl\n# Terraform example\nresource \"aws_ecs_service\" \"api\" {\n  name            = \"api-service\"\n  cluster         = aws_ecs_cluster.main.id\n  task_definition = aws_ecs_task_definition.api.arn\n  desired_count   = var.app_count\n\n  deployment_configuration {\n    maximum_percent         = 200\n    minimum_healthy_percent = 100\n  }\n}\n```\n\n## Container Orchestration\n- **Docker Best Practices**: Multi-stage builds\n- **Kubernetes Deployment**: Declarative configuration\n- **Service Mesh**: Traffic management\n- **Auto-Scaling**: Based on metrics\n- **Health Checks**: Liveness and readiness probes\n\n## Monitoring & Observability\n- **Centralized Logging**: ELK/Splunk\n- **Distributed Tracing**: Jaeger/Zipkin\n- **Metrics Collection**: Prometheus/Grafana\n- **Alerting Rules**: PagerDuty integration\n- **Performance Monitoring**: APM tools\n\n## Security Automation\n- **SAST**: Static code analysis\n- **DAST**: Dynamic security testing\n- **Container Scanning**: Vulnerability detection\n- **Secrets Scanning**: Prevent credential leaks\n- **Compliance Checks**: Policy as code\n\n```yaml\n# Security scanning in pipeline\nsecurity_scan:\n  stage: security\n  script:\n    - trivy image $IMAGE_NAME\n    - snyk test\n    - git-secrets --scan\n  allow_failure: false\n```\n\n## Release Management\n- **Semantic Versioning**: Major.Minor.Patch\n- **Changelog Generation**: Automated from commits\n- **Release Notes**: User-facing documentation\n- **Git Tags**: Mark releases\n- **Branch Protection**: Require reviews\n\n## Performance Optimization\n- **Pipeline Caching**: Dependencies and artifacts\n- **Parallel Jobs**: Maximize concurrency\n- **Conditional Builds**: Skip unchanged components\n- **Incremental Builds**: Build only changes\n- **Resource Optimization**: Right-size runners\n\n## Disaster Recovery\n- **Backup Automation**: Regular backups\n- **Disaster Recovery Plan**: Documented procedures\n- **RTO/RPO Targets**: Recovery objectives\n- **Failover Testing**: Regular drills\n- **Data Replication**: Multi-region setup\n\n## Best Practices Summary\n- Automate repetitive tasks\n- Version everything\n- Test automation code\n- Monitor pipeline performance\n- Document procedures\n- Practice rollbacks\n- Implement security early\n- Use infrastructure as code\n- Maintain environment parity\n- Keep pipelines simple",
  "tags": ["automation", "cicd", "devops", "deployment", "infrastructure"],
  "author": "DevOps Community",
  "detailedDescription": "Comprehensive automation and CI/CD guidelines covering build automation, deployment strategies, infrastructure as code, container orchestration, and monitoring best practices."
},
{
  "id": "automation-cicd-rules",
  "name": "Automation & CI/CD Best Practices",
  "description": "Build automation, continuous integration, and deployment pipeline best practices",
  "type": "rule",
  "category": "devops",
  "platforms": ["cursor", "windsurf"],
  "featured": true,
  "content": "# Automation & CI/CD Best Practices\n\n## CI/CD Principles\n- **Automate Everything**: From build to deployment\n- **Fail Fast**: Catch issues early in the pipeline\n- **Reproducible Builds**: Same input = same output\n- **Progressive Deployment**: Deploy gradually\n- **Rollback Capability**: Quick recovery from failures\n\n## Pipeline Architecture\n```yaml\n# Example CI/CD Pipeline\nstages:\n  - build\n  - test\n  - security\n  - deploy\n  - monitor\n\nbuild:\n  stage: build\n  script:\n    - npm install\n    - npm run build\n  artifacts:\n    paths:\n      - dist/\n\ntest:\n  stage: test\n  parallel:\n    matrix:\n      - TEST_TYPE: [unit, integration, e2e]\n  script:\n    - npm run test:$TEST_TYPE\n```\n\n## Build Automation\n- **Dependency Management**: Lock file for reproducibility\n- **Build Caching**: Speed up builds\n- **Artifact Management**: Store build outputs\n- **Multi-Stage Builds**: Optimize Docker images\n- **Environment Variables**: Externalize configuration\n\n## Testing Automation\n- **Parallel Testing**: Run tests concurrently\n- **Test Selection**: Run only affected tests\n- **Coverage Gates**: Minimum coverage requirements\n- **Performance Benchmarks**: Track performance\n- **Visual Regression**: Screenshot comparisons\n\n## Code Quality Gates\n- **Linting**: Enforce code standards\n- **Type Checking**: TypeScript strict mode\n- **Security Scanning**: Dependency vulnerabilities\n- **Code Coverage**: Minimum thresholds\n- **Complexity Analysis**: Cyclomatic complexity\n\n```javascript\n// Quality gate configuration\nmodule.exports = {\n  coverage: {\n    statements: 80,\n    branches: 75,\n    functions: 80,\n    lines: 80\n  },\n  complexity: {\n    max: 10\n  },\n  duplication: {\n    threshold: 3\n  }\n};\n```\n\n## Deployment Strategies\n- **Blue-Green Deployment**: Zero-downtime deployments\n- **Canary Releases**: Gradual rollout\n- **Feature Flags**: Toggle features without deployment\n- **Rolling Updates**: Update instances gradually\n- **Rollback Plan**: Quick recovery strategy\n\n## Infrastructure as Code\n- **Version Control**: Track infrastructure changes\n- **Terraform/CloudFormation**: Define infrastructure\n- **Immutable Infrastructure**: Replace, don't modify\n- **Environment Parity**: Dev/staging/prod consistency\n- **Secret Management**: Secure credential handling\n\n```hcl\n# Terraform example\nresource \"aws_ecs_service\" \"api\" {\n  name            = \"api-service\"\n  cluster         = aws_ecs_cluster.main.id\n  task_definition = aws_ecs_task_definition.api.arn\n  desired_count   = var.app_count\n\n  deployment_configuration {\n    maximum_percent         = 200\n    minimum_healthy_percent = 100\n  }\n}\n```\n\n## Container Orchestration\n- **Docker Best Practices**: Multi-stage builds\n- **Kubernetes Deployment**: Declarative configuration\n- **Service Mesh**: Traffic management\n- **Auto-Scaling**: Based on metrics\n- **Health Checks**: Liveness and readiness probes\n\n## Monitoring & Observability\n- **Centralized Logging**: ELK/Splunk\n- **Distributed Tracing**: Jaeger/Zipkin\n- **Metrics Collection**: Prometheus/Grafana\n- **Alerting Rules**: PagerDuty integration\n- **Performance Monitoring**: APM tools\n\n## Security Automation\n- **SAST**: Static code analysis\n- **DAST**: Dynamic security testing\n- **Container Scanning**: Vulnerability detection\n- **Secrets Scanning**: Prevent credential leaks\n- **Compliance Checks**: Policy as code\n\n```yaml\n# Security scanning in pipeline\nsecurity_scan:\n  stage: security\n  script:\n    - trivy image $IMAGE_NAME\n    - snyk test\n    - git-secrets --scan\n  allow_failure: false\n```\n\n## Release Management\n- **Semantic Versioning**: Major.Minor.Patch\n- **Changelog Generation**: Automated from commits\n- **Release Notes**: User-facing documentation\n- **Git Tags**: Mark releases\n- **Branch Protection**: Require reviews\n\n## Performance Optimization\n- **Pipeline Caching**: Dependencies and artifacts\n- **Parallel Jobs**: Maximize concurrency\n- **Conditional Builds**: Skip unchanged components\n- **Incremental Builds**: Build only changes\n- **Resource Optimization**: Right-size runners\n\n## Disaster Recovery\n- **Backup Automation**: Regular backups\n- **Disaster Recovery Plan**: Documented procedures\n- **RTO/RPO Targets**: Recovery objectives\n- **Failover Testing**: Regular drills\n- **Data Replication**: Multi-region setup\n\n## Best Practices Summary\n- Automate repetitive tasks\n- Version everything\n- Test automation code\n- Monitor pipeline performance\n- Document procedures\n- Practice rollbacks\n- Implement security early\n- Use infrastructure as code\n- Maintain environment parity\n- Keep pipelines simple",
  "tags": ["automation", "cicd", "devops", "deployment", "infrastructure"],
  "author": "DevOps Community",
  "detailedDescription": "Comprehensive automation and CI/CD guidelines covering build automation, deployment strategies, infrastructure as code, container orchestration, and monitoring best practices."
},
{
  "id": "system-design-planning",
  "name": "High-Level System Design & Planning",
  "description": "Architecture planning, system design principles, and scalable solution patterns",
  "type": "rule",
  "category": "architecture",
  "platforms": ["cursor", "windsurf"],
  "featured": true,
  "content": "# High-Level System Design & Planning\n\n## Design Principles\n- **Scalability**: Design for 10x growth\n- **Reliability**: 99.9%+ uptime targets\n- **Maintainability**: Easy to understand and modify\n- **Security**: Defense in depth\n- **Performance**: Sub-second response times\n\n## Architecture Patterns\n### Microservices Architecture\n```mermaid\ngraph TB\n    Gateway[API Gateway]\n    Auth[Auth Service]\n    User[User Service]\n    Order[Order Service]\n    Payment[Payment Service]\n    Queue[Message Queue]\n    \n    Gateway --> Auth\n    Gateway --> User\n    Gateway --> Order\n    Order --> Payment\n    Order --> Queue\n```\n\n### Event-Driven Architecture\n- **Event Sourcing**: Store events, not state\n- **CQRS**: Separate read and write models\n- **Saga Pattern**: Distributed transactions\n- **Event Bus**: Decoupled communication\n- **Dead Letter Queue**: Failed message handling\n\n## System Components\n### API Gateway\n- **Rate Limiting**: Protect backend services\n- **Authentication**: Centralized auth\n- **Load Balancing**: Distribute traffic\n- **Caching**: Response caching\n- **Monitoring**: Request tracking\n\n### Service Design\n- **Single Responsibility**: One service, one domain\n- **Database per Service**: Data isolation\n- **API Versioning**: Backward compatibility\n- **Health Checks**: Service monitoring\n- **Circuit Breakers**: Fault tolerance\n\n## Data Architecture\n### Database Selection\n```yaml\nRelational (PostgreSQL/MySQL):\n  - Strong consistency\n  - ACID transactions\n  - Complex queries\n  - Structured data\n\nNoSQL (MongoDB/DynamoDB):\n  - Flexible schema\n  - Horizontal scaling\n  - High throughput\n  - Semi-structured data\n\nCache (Redis/Memcached):\n  - Session storage\n  - Frequent reads\n  - Temporary data\n  - Real-time features\n\nSearch (Elasticsearch):\n  - Full-text search\n  - Log analysis\n  - Complex queries\n  - Analytics\n```\n\n### Data Patterns\n- **Sharding**: Horizontal partitioning\n- **Replication**: Master-slave setup\n- **Caching Strategy**: Cache-aside, write-through\n- **Data Lake**: Raw data storage\n- **Data Warehouse**: Analytics and reporting\n\n## Scalability Strategies\n### Horizontal Scaling\n- **Load Balancers**: Distribute traffic\n- **Auto-scaling**: Dynamic instance management\n- **Database Sharding**: Partition data\n- **CDN**: Global content delivery\n- **Stateless Services**: Easy scaling\n\n### Vertical Scaling\n- **Resource Optimization**: CPU/Memory tuning\n- **Connection Pooling**: Efficient resource use\n- **Query Optimization**: Database performance\n- **Caching Layers**: Reduce load\n- **Code Optimization**: Algorithm improvements\n\n## Communication Patterns\n### Synchronous\n- **REST APIs**: Resource-based\n- **GraphQL**: Flexible queries\n- **gRPC**: High performance\n- **WebSockets**: Real-time bidirectional\n\n### Asynchronous\n- **Message Queues**: RabbitMQ, SQS\n- **Event Streams**: Kafka, Kinesis\n- **Pub/Sub**: Redis, Google Pub/Sub\n- **Webhooks**: Event notifications\n\n## Security Architecture\n### Defense Layers\n```\n1. Edge Security (CDN/WAF)\n2. Network Security (VPC, Firewalls)\n3. Application Security (Auth, Input validation)\n4. Data Security (Encryption at rest/transit)\n5. Infrastructure Security (IAM, Secrets management)\n```\n\n### Security Patterns\n- **Zero Trust**: Never trust, always verify\n- **Principle of Least Privilege**: Minimal access\n- **Defense in Depth**: Multiple security layers\n- **Encryption Everywhere**: TLS, data encryption\n- **Security by Design**: Built-in, not bolt-on\n\n## Monitoring & Observability\n### Three Pillars\n1. **Metrics**: Quantitative measurements\n2. **Logs**: Event records\n3. **Traces**: Request flow tracking\n\n### Implementation\n```yaml\nMetrics (Prometheus/DataDog):\n  - Response times\n  - Error rates\n  - Resource usage\n  - Business metrics\n\nLogging (ELK/Splunk):\n  - Centralized logging\n  - Structured logs\n  - Log aggregation\n  - Search and analysis\n\nTracing (Jaeger/Zipkin):\n  - Distributed tracing\n  - Latency analysis\n  - Dependency mapping\n  - Performance bottlenecks\n```\n\n## Disaster Recovery\n### Planning\n- **RTO**: Recovery Time Objective\n- **RPO**: Recovery Point Objective\n- **Backup Strategy**: Regular automated backups\n- **Failover Plan**: Automatic or manual\n- **Testing**: Regular DR drills\n\n### Implementation\n- **Multi-region**: Geographic distribution\n- **Data Replication**: Real-time sync\n- **Blue-Green Deployment**: Quick rollback\n- **Chaos Engineering**: Failure testing\n- **Runbooks**: Documented procedures\n\n## Cost Optimization\n- **Right-sizing**: Match resources to load\n- **Reserved Instances**: Long-term savings\n- **Spot Instances**: Non-critical workloads\n- **Auto-scaling**: Scale with demand\n- **Resource Tagging**: Cost tracking\n\n## Documentation\n### Architecture Diagrams\n- **C4 Model**: Context, Container, Component, Code\n- **Sequence Diagrams**: Request flows\n- **ER Diagrams**: Database schema\n- **Network Diagrams**: Infrastructure layout\n- **Data Flow Diagrams**: Information movement\n\n### Technical Documentation\n- **API Documentation**: OpenAPI/Swagger\n- **Architecture Decision Records**: ADRs\n- **Runbooks**: Operational procedures\n- **Onboarding Guides**: New developer setup\n- **Troubleshooting Guides**: Common issues\n\n## Design Process\n1. **Requirements Gathering**: Functional and non-functional\n2. **Capacity Planning**: Expected load and growth\n3. **Technology Selection**: Choose appropriate stack\n4. **Proof of Concept**: Validate approach\n5. **Incremental Development**: Build iteratively\n6. **Load Testing**: Verify scalability\n7. **Security Review**: Threat modeling\n8. **Documentation**: Keep updated\n9. **Post-mortem**: Learn from issues\n10. **Continuous Improvement**: Iterate and optimize",
  "tags": ["architecture", "system-design", "scalability", "planning", "distributed-systems"],
  "author": "System Architects Guild",
  "detailedDescription": "Comprehensive system design guidelines covering architecture patterns, scalability strategies, data architecture, security design, monitoring, and disaster recovery planning for building large-scale distributed systems."
}]
