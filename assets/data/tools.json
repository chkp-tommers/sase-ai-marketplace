[
  {
    "id": "peekaboo-mcp",
    "name": "Peekaboo",
    "description": "A macOS-only MCP server that enables AI agents to capture screenshots of applications, or the entire system, with optional visual question answering through local or remote AI models.",
    "longDescription": "Peekaboo is a macOS-only MCP server that enables AI agents to capture screenshots of applications, or the entire system, with optional visual question answering through local or remote AI models. Without screenshots, agents debug blind—Peekaboo gives them eyes.",
    "type": "mcp",
    "category": "automation",
    "platforms": ["windsurf", "cursor", "claude"],
    "featured": true,
    "command": "npx",
    "args": ["@peekaboo/mcp-server"],
    "env": {},
    "requirements": {
      "os": "macOS",
      "node": ">=18.0.0",
      "dependencies": ["sharp", "screenshot-desktop"]
    },
    "installation": {
      "windsurf": "Add to .windsurf/mcp_config.json",
      "cursor": "Add to cursor settings → Features → MCP",
      "claude": "Configure in MCP settings"
    },
    "installationSteps": [
      "Open Cursor Settings",
      "Navigate to Cursor Settings → Features → MCP",
      "Click the \"+ Add New MCP Server\" button",
      "Configure the Server",
      "Name: Give your server a nickname",
      "Type: Select the transport type (stdio or sse)",
      "Command/URL: Enter either: For stdio servers: A valid shell command to run the server",
      "For sse servers: The URL of the SSE endpoint"
    ],
    "exampleConfig": {
      "stdio": {
        "command": "node",
        "args": ["/req-quickstart/peekaboo-server.js"]
      },
      "sse": {
        "url": "http://localhost:8080/sse"
      }
    },
    "features": [
      "Screenshot capture of entire system or specific applications",
      "Visual question answering through AI models",
      "Local or remote AI model integration",
      "Built specifically for macOS",
      "Seamless integration with MCP-compatible tools"
    ],
    "github": "https://github.com/peekaboo-ai/peekaboo-mcp",
    "readme": "# Peekaboo MCP\n\nA macOS-only MCP server for AI-powered screenshot analysis.\n\n## Installation\n\n```bash\nnpm install -g @peekaboo/mcp-server\n```\n\n## Usage\n\nConfigure in your MCP settings to enable visual AI capabilities."
  },
  {
    "id": "typescript-expert-prompt",
    "name": "TypeScript Expert",
    "description": "You are an expert in TypeScript, Node.js, Next.js App Router, React, and Modern UI/UX frameworks. Follow the user's requirements carefully & to the letter.",
    "type": "prompt",
    "category": "development",
    "platforms": ["cursor", "copilot", "claude"],
    "featured": true,
    "content": "You are an expert in TypeScript, Node.js, Next.js App Router, React, and Modern UI/UX frameworks (e.g., TailwindCSS, Shadcn, Radix). You are thoughtful, give nuanced answers, and are brilliant at reasoning. You carefully provide accurate, factual, thoughtful answers, and are a genius at reasoning.\n\n- Follow the user's requirements carefully & to the letter.\n- First think step-by-step - describe your plan for what to build in pseudocode, written out in great detail.\n- Confirm, then write code!\n- Always write correct, best practice, DRY principle (Don't Repeat Yourself), bug free, fully functional and working code also it should be aligned to listed rules down below at Code Implementation Guidelines.\n- Focus on easy and readability code, over being performant.\n- Fully implement all requested functionality.\n- Leave NO todo's, placeholders or missing pieces.\n- Ensure code is complete! Verify thoroughly finalised.\n- Include all required imports, and ensure proper naming or key components.\n- Be concise Minimize any other prose.\n- If you think there might not be a correct answer, you say so, instead of guessing.\n- If you do not know the answer, say so, instead of guessing.\n\n### Coding Environment\nThe user asks questions about the following coding languages:\n- ReactJS\n- NextJS\n- JavaScript\n- TypeScript\n- TailwindCSS\n- HTML\n- CSS\n\n### Code Implementation Guidelines\nFollow these rules when you write code:\n- Use early returns whenever possible to make the code more readable.\n- Always use Tailwind classes for styling HTML elements; avoid using CSS or tags.\n- Use 'class:' instead of the tertiary operator in class tags whenever possible.\n- Use descriptive variable and function/const names. Also, event functions should be named with a 'handle' prefix, like 'handleClick' for onClick and 'handleKeyDown' for onKeyDown.\n- Implement error handling and edge cases early.",
    "tags": [
      "TypeScript",
      "React",
      "Next.js",
      "TailwindCSS",
      "shadcn",
      "radix"
    ],
    "author": "CodeRabbit",
    "detailedDescription": "A comprehensive TypeScript development prompt that guides AI assistants to provide expert-level code reviews, architectural advice, and implementation guidance. Focuses on modern React/Next.js development with emphasis on best practices, clean code, and proper TypeScript usage.",
    "uses": 12450,
    "rating": 4.9
  },
  {
    "id": "frontend-developer-chatmode",
    "name": "Front-End Developer",
    "description": "Specialized AI assistant configuration for front-end development with modern frameworks and best practices",
    "type": "chatmode",
    "category": "development",
    "platforms": ["windsurf", "cursor", "claude"],
    "featured": true,
    "systemPrompt": "You are a Senior Front-End Developer and an Expert in ReactJS, NextJS, and Modern UI/UX frameworks (e.g., TailwindCSS, Shadcn, Radix). You are thoughtful, give nuanced answers, and are brilliant at reasoning. You carefully provide accurate, factual, thoughtful answers, and are a genius at reasoning.\n\n- Follow the user's requirements carefully & to the letter.\n- First think step-by-step - describe your plan for what to build in pseudocode, written out in great detail.\n- Confirm, then write code!\n- Always write correct, best practice, DRY principle (Don't Repeat Yourself), bug free, fully functional and working code also it should be aligned to listed rules down below at Code Implementation Guidelines.\n- Focus on easy and readability code, over being performant.\n- Fully implement all requested functionality.\n- Leave NO todo's, placeholders or missing pieces.\n- Ensure code is complete! Verify thoroughly finalised.\n- Include all required imports, and ensure proper naming or key components.\n- Be concise Minimize any other prose.\n- If you think there might not be a correct answer, you say so, instead of guessing.\n- If you do not know the answer, say so, instead of guessing.\n\n### Coding Environment\nThe user asks questions about the following coding languages:\n- ReactJS\n- NextJS\n- JavaScript \n- TypeScript\n- TailwindCSS\n- HTML\n- CSS\n\n### Code Implementation Guidelines\nFollow these rules when you write code:\n- Use early returns whenever possible to make the code more readable.\n- Always use Tailwind classes for styling HTML elements; avoid using CSS or tags.\n- Use 'class:' instead of the tertiary operator in class tags whenever possible.\n- Use descriptive variable and function/const names. Also, event functions should be named with a 'handle' prefix, like 'handleClick' for onClick and 'handleKeyDown' for onKeyDown.\n- Implement error handling and edge cases early.",
    "temperature": 0.3,
    "maxTokens": 4000,
    "tools": ["react", "nextjs", "tailwindcss", "typescript"],
    "tags": ["React", "Next.js", "TailwindCSS", "UI/UX", "frontend"],
    "author": "Frontend Guild",
    "detailedDescription": "A specialized chat mode configuration that transforms your AI assistant into an expert front-end developer. Focuses on React, Next.js, and modern UI frameworks with emphasis on clean code, best practices, and comprehensive implementation.",
    "uses": 8750,
    "rating": 4.8
  },
  {
    "id": "filesystem-mcp",
    "name": "Filesystem MCP",
    "description": "File system operations MCP server for reading, writing, and managing files",
    "type": "mcp",
    "category": "development",
    "platforms": ["windsurf", "cursor", "claude"],
    "featured": false,
    "command": "npx",
    "args": ["@filesystem/mcp"],
    "env": {
      "ALLOWED_PATHS": "/workspace"
    }
  },
  {
    "id": "git-mcp",
    "name": "Git MCP",
    "description": "Git operations MCP server for version control management",
    "type": "mcp",
    "category": "development",
    "platforms": ["windsurf", "cursor", "claude"],
    "featured": true,
    "command": "git-mcp",
    "args": [],
    "env": {}
  },
  {
    "id": "code-review-prompt",
    "name": "Code Review Assistant",
    "description": "Comprehensive code review prompt with security and performance focus",
    "type": "prompt",
    "category": "development",
    "platforms": ["cursor", "copilot", "claude"],
    "featured": true,
    "content": "# Code Review Assistant\n\nYou are an expert code reviewer with deep knowledge of security, performance, and best practices.\n\n## Your Role\n- Review code for bugs, security vulnerabilities, and performance issues\n- Suggest improvements and alternatives\n- Check for code style and convention adherence\n- Ensure proper error handling and edge cases\n\n## Review Checklist\n1. **Security**: SQL injection, XSS, authentication, authorization\n2. **Performance**: Algorithms, database queries, memory usage\n3. **Maintainability**: Code clarity, documentation, modularity\n4. **Testing**: Unit tests, edge cases, error scenarios\n5. **Standards**: Coding conventions, naming, structure\n\n## Output Format\nProvide feedback in this structure:\n- **Summary**: Overall assessment\n- **Critical Issues**: Security/performance problems\n- **Suggestions**: Improvements and alternatives\n- **Positives**: What's done well\n\nBe constructive and educational in your feedback."
  },
  {
    "id": "api-design-prompt",
    "name": "API Design Expert",
    "description": "REST API design and documentation specialist prompt",
    "type": "prompt",
    "category": "architecture",
    "platforms": ["cursor", "copilot", "claude"],
    "featured": false,
    "content": "# API Design Expert\n\nYou are an expert in REST API design, following industry best practices and standards.\n\n## Your Expertise\n- RESTful API design patterns\n- OpenAPI/Swagger documentation\n- Authentication and authorization\n- Error handling and status codes\n- API versioning strategies\n- Performance optimization\n\n## Design Principles\n1. **Consistency**: Uniform naming and patterns\n2. **Clarity**: Self-documenting endpoints\n3. **Security**: Proper authentication/authorization\n4. **Performance**: Efficient data transfer\n5. **Maintainability**: Versioning and backwards compatibility\n\nProvide detailed API specifications with examples."
  },
  {
    "id": "database-optimization-prompt",
    "name": "Database Optimization Expert",
    "description": "Database performance and optimization specialist",
    "type": "prompt",
    "category": "database",
    "platforms": ["cursor", "copilot", "claude"],
    "featured": false,
    "content": "# Database Optimization Expert\n\nSpecialize in database performance tuning, query optimization, and schema design.\n\n## Focus Areas\n- Query optimization and indexing\n- Schema design and normalization\n- Performance monitoring and analysis\n- Scaling strategies (horizontal/vertical)\n- Caching implementations\n\n## Analysis Framework\n1. **Query Performance**: Execution plans, indexing\n2. **Schema Design**: Normalization, relationships\n3. **Scalability**: Partitioning, replication\n4. **Monitoring**: Metrics, alerting\n\nProvide specific, actionable recommendations."
  },
  {
    "id": "api-architect",
    "name": "API Architect",
    "description": "Chat mode for designing and documenting RESTful APIs",
    "type": "chatmode",
    "category": "architecture",
    "platforms": ["windsurf", "cursor", "claude"],
    "featured": true,
    "systemPrompt": "You are an expert API architect specializing in RESTful API design, microservices architecture, and API documentation. You help design scalable, maintainable APIs following industry best practices.\n\n## Your Expertise:\n- RESTful API design patterns\n- OpenAPI/Swagger specification\n- Authentication & authorization (OAuth, JWT)\n- API versioning strategies\n- Error handling & status codes\n- Rate limiting & caching\n- Microservices architecture\n- API security best practices\n\n## Design Process:\n1. Understand requirements and use cases\n2. Design resource hierarchy and endpoints\n3. Define request/response schemas\n4. Specify authentication and authorization\n5. Document with OpenAPI specification\n6. Plan versioning and evolution strategy\n\nAlways provide concrete examples and follow REST principles."
  },
  {
    "id": "security-auditor",
    "name": "Security Auditor",
    "description": "Security-focused code review and vulnerability assessment",
    "type": "chatmode",
    "category": "security",
    "platforms": ["windsurf", "cursor", "claude"],
    "featured": false,
    "systemPrompt": "You are a cybersecurity expert specializing in application security, code review, and vulnerability assessment.\n\n## Security Focus Areas:\n- Input validation and sanitization\n- Authentication and authorization flaws\n- SQL injection and NoSQL injection\n- Cross-site scripting (XSS)\n- Cross-site request forgery (CSRF)\n- Insecure direct object references\n- Security misconfigurations\n- Cryptographic vulnerabilities\n- Business logic flaws\n\n## Methodology:\n1. Analyze code for common vulnerabilities\n2. Check for proper input validation\n3. Review authentication/authorization logic\n4. Assess data handling practices\n5. Evaluate cryptographic implementations\n6. Provide remediation recommendations\n\nPrioritize findings by severity and exploitability."
  },
  {
    "id": "performance-optimizer",
    "name": "Performance Optimizer",
    "description": "Application performance analysis and optimization specialist",
    "type": "chatmode",
    "category": "performance",
    "platforms": ["windsurf", "cursor", "claude"],
    "featured": false,
    "systemPrompt": "You are a performance optimization expert specializing in application performance, scalability, and efficiency.\n\n## Optimization Areas:\n- Algorithm complexity analysis\n- Database query optimization\n- Memory management\n- Caching strategies\n- Load balancing\n- CDN implementation\n- Concurrent programming\n- Resource utilization\n\n## Analysis Process:\n1. Identify performance bottlenecks\n2. Analyze algorithmic complexity\n3. Review database queries and indexing\n4. Assess caching opportunities\n5. Evaluate resource usage patterns\n6. Recommend optimization strategies\n\nProvide measurable improvements and benchmarking guidance."
  },
  {
    "id": "typescript-strict-rules",
    "name": "TypeScript Strict Configuration",
    "description": "Strict TypeScript configuration rules for type safety",
    "type": "rule",
    "category": "development",
    "platforms": ["cursor", "windsurf"],
    "featured": false,
    "content": "# TypeScript Strict Configuration\n\n## Compiler Options\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"noImplicitReturns\": true,\n    \"noImplicitThis\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true\n  }\n}\n```\n\n## Coding Standards\n- Use explicit type annotations\n- Handle null/undefined cases\n- Prefer interfaces over types for objects\n- Use strict function signatures\n- Enable all strict checks"
  },
  {
    "id": "react-best-practices",
    "name": "React Best Practices Rules",
    "description": "React development best practices and patterns",
    "type": "rule",
    "category": "frontend",
    "platforms": ["cursor", "windsurf"],
    "featured": false,
    "content": "# React Best Practices\n\n## Component Guidelines\n- Use functional components with hooks\n- Implement proper error boundaries\n- Optimize with React.memo when needed\n- Use useCallback and useMemo appropriately\n- Follow naming conventions (PascalCase)\n\n## State Management\n- Keep state close to where it's used\n- Use useReducer for complex state logic\n- Implement proper dependency arrays\n- Avoid unnecessary re-renders\n\n## Performance\n- Code splitting with React.lazy\n- Virtualization for large lists\n- Proper key props for lists\n- Minimize bundle size"
  },
  {
    "id": "api-security-rules",
    "name": "API Security Guidelines",
    "description": "Security rules and practices for API development",
    "type": "rule",
    "category": "security",
    "platforms": ["cursor", "windsurf"],
    "featured": true,
    "content": "# API Security Guidelines\n\n## Authentication & Authorization\n- Implement proper JWT token validation\n- Use HTTPS for all API endpoints\n- Implement rate limiting\n- Validate all input parameters\n- Use principle of least privilege\n\n## Data Protection\n- Encrypt sensitive data at rest\n- Use parameterized queries (prevent SQL injection)\n- Implement proper CORS policies\n- Log security events\n- Regular security audits\n\n## Error Handling\n- Don't expose sensitive information in errors\n- Use generic error messages\n- Log detailed errors server-side\n- Implement proper status codes"
  },
  {
    "id": "react-comprehensive-rules",
    "name": "React Comprehensive Development Rules",
    "description": "Complete React development guidelines with hooks, patterns, and best practices",
    "type": "rule",
    "category": "frontend",
    "platforms": ["cursor", "windsurf"],
    "featured": true,
    "content": "# React Comprehensive Development Rules\n\n## Component Design\n- Use functional components with hooks instead of class components\n- Use custom hooks for reusable logic\n- Use the Context API for state management when needed\n- Use proper prop validation with PropTypes or TypeScript\n- Use React.memo for performance optimization when necessary\n- Use fragments to avoid unnecessary wrapper divs\n\n## Hooks Best Practices\n- Use useState for simple local state\n- Use useReducer for complex state logic\n- Use useEffect for side effects, cleanup in return function\n- Use useContext to consume context values\n- Use useMemo to memoize expensive computations\n- Use useCallback to memoize functions passed as props\n- Use useRef for DOM references and mutable values\n- Create custom hooks to extract reusable component logic\n\n## State Management\n- Lift state up when needed to share state between components\n- Keep state as local as possible\n- Use immutable update patterns\n- Avoid deeply nested state objects\n- Consider using state management libraries (Redux, Zustand, Jotai) for complex apps\n\n## Performance Optimization\n- Use React.lazy() and Suspense for code splitting\n- Implement virtualization for long lists (react-window, react-virtualized)\n- Optimize re-renders with proper dependency arrays\n- Use production builds for deployment\n- Profile components with React DevTools\n- Avoid inline function definitions in render\n- Use key prop correctly in lists\n\n## Error Handling\n- Implement Error Boundaries for graceful error handling\n- Use try-catch in async operations\n- Provide meaningful error messages to users\n- Log errors for debugging\n- Handle loading and error states in components\n\n## Testing\n- Write unit tests with Jest and React Testing Library\n- Test user interactions, not implementation details\n- Use data-testid for reliable element selection\n- Mock external dependencies\n- Test accessibility with jest-axe\n\n## Code Organization\n- Organize components by feature, not by type\n- Keep components small and focused (single responsibility)\n- Extract complex logic into custom hooks\n- Use absolute imports with path aliases\n- Follow consistent file naming conventions",
    "tags": ["React", "hooks", "components", "state-management", "performance"],
    "author": "React Community",
    "detailedDescription": "Comprehensive React development rules covering modern patterns, hooks usage, performance optimization, and best practices for building scalable React applications."
  },
  {
    "id": "frontend-architecture-rules",
    "name": "Frontend Architecture Best Practices",
    "description": "General frontend development architecture patterns and principles",
    "type": "rule",
    "category": "frontend",
    "platforms": ["cursor", "windsurf"],
    "featured": true,
    "content": "# Frontend Architecture Best Practices\n\n## Architecture Principles\n- Separation of concerns (UI, logic, data)\n- Component-based architecture\n- Unidirectional data flow\n- Immutability and pure functions\n- Progressive enhancement\n- Mobile-first responsive design\n\n## Project Structure\n```\nsrc/\n├── components/      # Reusable UI components\n├── features/        # Feature-based modules\n├── hooks/          # Custom hooks\n├── services/       # API and external services\n├── utils/          # Helper functions\n├── styles/         # Global styles\n├── types/          # TypeScript types\n└── constants/      # App constants\n```\n\n## Component Design\n- Single Responsibility Principle\n- Composition over inheritance\n- Props interface documentation\n- Default props where appropriate\n- Proper prop types validation\n- Consistent naming conventions\n\n## State Management Patterns\n- Local state for component-specific data\n- Global state for app-wide data\n- Server state for API data (React Query, SWR)\n- URL state for navigation params\n- Form state management (React Hook Form, Formik)\n\n## Performance Strategies\n- Code splitting and lazy loading\n- Bundle size optimization\n- Image optimization (WebP, lazy loading)\n- Caching strategies\n- Service workers for offline support\n- Web Vitals monitoring (LCP, FID, CLS)\n\n## CSS Architecture\n- CSS Modules or CSS-in-JS\n- BEM naming convention\n- Utility-first with Tailwind CSS\n- Design system tokens\n- Responsive breakpoints\n- CSS custom properties\n\n## API Integration\n- Centralized API client\n- Request/response interceptors\n- Error handling middleware\n- Request cancellation\n- Retry logic\n- Type-safe API calls\n\n## Security Best Practices\n- Input sanitization\n- XSS prevention\n- CSRF protection\n- Content Security Policy\n- Secure authentication flow\n- Environment variables for secrets\n\n## Accessibility (a11y)\n- Semantic HTML\n- ARIA labels and roles\n- Keyboard navigation\n- Focus management\n- Screen reader support\n- Color contrast compliance\n\n## Testing Strategy\n- Unit tests for utilities\n- Integration tests for features\n- E2E tests for critical paths\n- Visual regression testing\n- Performance testing\n- Accessibility testing",
    "tags": ["frontend", "architecture", "performance", "accessibility", "security"],
    "author": "Frontend Masters",
    "detailedDescription": "Comprehensive frontend architecture guidelines covering project structure, component design, state management, performance optimization, and best practices for building modern web applications."
  },
  {
    "id": "backend-development-rules",
    "name": "Backend Development Best Practices",
    "description": "Comprehensive backend development patterns for scalable server applications",
    "type": "rule",
    "category": "backend",
    "platforms": ["cursor", "windsurf"],
    "featured": true,
    "content": "# Backend Development Best Practices\n\n## Architecture Patterns\n- **Clean Architecture**: Separate business logic from infrastructure\n- **Microservices**: When appropriate, design loosely coupled services\n- **API Gateway**: Centralize API management and routing\n- **Event-Driven**: Use message queues for async operations\n- **CQRS**: Separate read and write operations when beneficial\n\n## API Design Principles\n- **RESTful Standards**: Use proper HTTP methods and status codes\n- **Versioning**: Implement API versioning (URL or header-based)\n- **Documentation**: Use OpenAPI/Swagger for API documentation\n- **Consistency**: Uniform response formats and naming conventions\n- **Pagination**: Implement cursor or offset-based pagination\n- **Rate Limiting**: Protect APIs from abuse\n\n## Database Design\n- **Normalization**: Follow normal forms when appropriate\n- **Indexing**: Create indexes for frequently queried columns\n- **Migrations**: Version control database schema changes\n- **Connection Pooling**: Optimize database connections\n- **Query Optimization**: Use EXPLAIN to analyze queries\n- **Caching**: Implement Redis/Memcached for frequently accessed data\n\n## Authentication & Authorization\n- **JWT Tokens**: Stateless authentication with proper expiration\n- **OAuth 2.0**: For third-party integrations\n- **RBAC**: Role-based access control\n- **API Keys**: For service-to-service communication\n- **Session Management**: Secure session handling\n- **Password Security**: Bcrypt/Argon2 for hashing\n\n## Error Handling\n- **Consistent Error Format**: Standardized error responses\n- **Error Codes**: Machine-readable error identification\n- **Logging**: Structured logging with appropriate levels\n- **Monitoring**: Real-time error tracking (Sentry, DataDog)\n- **Graceful Degradation**: Fallback mechanisms\n\n## Performance Optimization\n- **Caching Strategies**: Multi-level caching (CDN, application, database)\n- **Async Processing**: Background jobs for heavy operations\n- **Database Optimization**: Query optimization, connection pooling\n- **Load Balancing**: Distribute traffic across instances\n- **Horizontal Scaling**: Design for scalability\n- **Resource Management**: Memory and CPU optimization\n\n## Security Best Practices\n- **Input Validation**: Validate all incoming data\n- **SQL Injection Prevention**: Use parameterized queries\n- **XSS Prevention**: Sanitize output data\n- **HTTPS Only**: Enforce SSL/TLS\n- **Security Headers**: HSTS, CSP, X-Frame-Options\n- **Dependency Scanning**: Regular security audits\n- **Secrets Management**: Use vault services\n\n## Testing Strategy\n- **Unit Tests**: Test individual functions/methods\n- **Integration Tests**: Test component interactions\n- **API Tests**: Test endpoints with various scenarios\n- **Load Tests**: Verify performance under stress\n- **Security Tests**: Penetration testing\n- **Contract Tests**: Ensure API compatibility\n\n## DevOps Practices\n- **CI/CD**: Automated testing and deployment\n- **Containerization**: Docker for consistency\n- **Orchestration**: Kubernetes for container management\n- **Infrastructure as Code**: Terraform/CloudFormation\n- **Monitoring**: APM tools (New Relic, AppDynamics)\n- **Logging**: Centralized logging (ELK stack)\n\n## Code Organization\n```\nsrc/\n├── controllers/    # Request handlers\n├── services/       # Business logic\n├── models/         # Data models\n├── repositories/   # Data access layer\n├── middleware/     # Custom middleware\n├── utils/          # Helper functions\n├── config/         # Configuration files\n└── tests/          # Test files\n```",
    "tags": ["backend", "api", "security", "performance", "architecture"],
    "author": "Backend Engineering Team",
    "detailedDescription": "Comprehensive backend development guidelines covering architecture patterns, API design, database management, security, performance optimization, and DevOps practices for building scalable server applications."
  },
  {
    "id": "nodejs-development-rules",
    "name": "Node.js Development Best Practices",
    "description": "Node.js specific patterns and best practices for server-side JavaScript",
    "type": "rule",
    "category": "backend",
    "platforms": ["cursor", "windsurf"],
    "featured": true,
    "content": "# Node.js Development Best Practices\n\n## Core Principles\n- **Asynchronous Programming**: Use async/await over callbacks\n- **Error-First Callbacks**: Follow Node.js convention\n- **Event-Driven Architecture**: Leverage EventEmitter\n- **Non-Blocking I/O**: Avoid synchronous operations\n- **Small Modules**: Create focused, reusable modules\n\n## Project Structure\n```\nproject/\n├── src/\n│   ├── controllers/\n│   ├── services/\n│   ├── models/\n│   ├── middleware/\n│   ├── routes/\n│   ├── utils/\n│   └── config/\n├── tests/\n├── scripts/\n└── package.json\n```\n\n## Express.js Best Practices\n- **Middleware Order**: Body parsers → custom middleware → routes → error handlers\n- **Router Organization**: Use Express Router for modular routes\n- **Error Handling**: Centralized error handling middleware\n- **Validation**: Use express-validator or Joi\n- **Security**: Helmet.js for security headers\n- **CORS**: Configure properly for production\n\n## Async Patterns\n```javascript\n// Good: async/await with proper error handling\nasync function processData(data) {\n  try {\n    const result = await someAsyncOperation(data);\n    return result;\n  } catch (error) {\n    logger.error('Processing failed:', error);\n    throw new AppError('Data processing failed', 500);\n  }\n}\n\n// Promise.all for parallel operations\nconst [user, posts] = await Promise.all([\n  getUserById(id),\n  getPostsByUserId(id)\n]);\n```\n\n## Error Handling\n- **Custom Error Classes**: Extend Error for app-specific errors\n- **Global Error Handler**: Catch unhandled errors\n- **Async Error Wrapper**: Wrap async route handlers\n- **Logging**: Use Winston or Pino for structured logging\n- **Process Events**: Handle uncaughtException and unhandledRejection\n\n## Performance Optimization\n- **Clustering**: Use PM2 or native cluster module\n- **Caching**: Implement Redis for session and data caching\n- **Database Pooling**: Connection pooling for databases\n- **Stream Processing**: Use streams for large data\n- **Compression**: Enable gzip compression\n- **Rate Limiting**: Protect against abuse\n\n## Security Practices\n- **Environment Variables**: Use dotenv for configuration\n- **Input Validation**: Validate all user inputs\n- **Authentication**: Implement JWT properly\n- **HTTPS**: Always use in production\n- **Dependencies**: Regular updates and audit\n- **SQL Injection**: Use parameterized queries\n\n## Database Integration\n- **ORM/ODM**: Use Sequelize, TypeORM, or Mongoose\n- **Migrations**: Version control schema changes\n- **Connection Management**: Proper pooling\n- **Transactions**: Use for data consistency\n- **Query Optimization**: Monitor and optimize slow queries\n\n## Testing\n- **Unit Tests**: Jest or Mocha for unit testing\n- **Integration Tests**: Supertest for API testing\n- **Test Coverage**: Aim for >80% coverage\n- **Mocking**: Mock external dependencies\n- **CI/CD**: Automated testing in pipeline\n\n## Production Considerations\n- **Process Manager**: Use PM2 for production\n- **Health Checks**: Implement health endpoints\n- **Graceful Shutdown**: Handle SIGTERM properly\n- **Memory Leaks**: Monitor and prevent\n- **Logging**: Structured, leveled logging\n- **Monitoring**: APM tools integration\n\n## Common Patterns\n```javascript\n// Repository Pattern\nclass UserRepository {\n  async findById(id) {\n    return await User.findByPk(id);\n  }\n  \n  async create(userData) {\n    return await User.create(userData);\n  }\n}\n\n// Service Layer\nclass UserService {\n  constructor(userRepository) {\n    this.userRepository = userRepository;\n  }\n  \n  async getUserProfile(userId) {\n    const user = await this.userRepository.findById(userId);\n    if (!user) {\n      throw new NotFoundError('User not found');\n    }\n    return this.formatUserProfile(user);\n  }\n}\n\n// Middleware Pattern\nconst authenticate = async (req, res, next) => {\n  try {\n    const token = req.headers.authorization?.split(' ')[1];\n    const decoded = await verifyToken(token);\n    req.user = decoded;\n    next();\n  } catch (error) {\n    next(new UnauthorizedError('Invalid token'));\n  }\n};\n```",
    "tags": ["nodejs", "express", "async", "performance", "security"],
    "author": "Node.js Foundation",
    "detailedDescription": "Comprehensive Node.js development guidelines covering async patterns, Express.js best practices, error handling, performance optimization, security, and production deployment strategies."
  },
  {
    "id": "mongodb-best-practices",
    "name": "MongoDB Database Best Practices",
    "description": "MongoDB design patterns, optimization, and best practices for NoSQL development",
    "type": "rule",
    "category": "database",
    "platforms": ["cursor", "windsurf"],
    "featured": true,
    "content": "# MongoDB Best Practices\n\n## Schema Design Principles\n- **Document Structure**: Design based on data access patterns\n- **Embedding vs Referencing**: Embed for 1:1 and 1:few, reference for 1:many\n- **Denormalization**: Optimize for read performance\n- **Schema Validation**: Use JSON Schema validation\n- **Avoid Large Documents**: Keep documents under 16MB\n\n## Data Modeling Patterns\n```javascript\n// Embedding Pattern (1:few)\n{\n  _id: ObjectId('...'),\n  name: 'John Doe',\n  addresses: [\n    { type: 'home', street: '123 Main St', city: 'Boston' },\n    { type: 'work', street: '456 Office Blvd', city: 'Cambridge' }\n  ]\n}\n\n// Reference Pattern (1:many)\n// User document\n{ _id: ObjectId('...'), name: 'John Doe' }\n// Order documents\n{ _id: ObjectId('...'), userId: ObjectId('...'), total: 99.99 }\n\n// Hybrid Pattern\n{\n  _id: ObjectId('...'),\n  name: 'Blog Post',\n  author: { id: ObjectId('...'), name: 'Jane Smith' }, // Denormalized\n  comments: [ // Embedded recent comments\n    { text: 'Great post!', date: ISODate('...') }\n  ],\n  commentCount: 150 // Counter for all comments\n}\n```\n\n## Indexing Strategies\n- **Single Field Index**: For simple queries\n- **Compound Index**: For queries on multiple fields\n- **Multikey Index**: For array fields\n- **Text Index**: For text search\n- **Geospatial Index**: For location queries\n- **TTL Index**: For automatic document expiration\n\n```javascript\n// Creating indexes\ndb.users.createIndex({ email: 1 }, { unique: true });\ndb.posts.createIndex({ userId: 1, createdAt: -1 });\ndb.products.createIndex({ name: 'text', description: 'text' });\ndb.events.createIndex({ expireAt: 1 }, { expireAfterSeconds: 0 });\n```\n\n## Query Optimization\n- **Use Projection**: Return only needed fields\n- **Limit Results**: Use limit() for pagination\n- **Use Covered Queries**: Query only indexed fields\n- **Avoid $where**: Use standard query operators\n- **Explain Plans**: Analyze query performance\n\n```javascript\n// Optimized query example\ndb.users.find(\n  { status: 'active', age: { $gte: 18 } },\n  { name: 1, email: 1, _id: 0 }\n).limit(20).hint({ status: 1, age: 1 });\n```\n\n## Aggregation Pipeline\n```javascript\n// Complex aggregation example\ndb.orders.aggregate([\n  { $match: { status: 'completed' } },\n  { $lookup: {\n      from: 'users',\n      localField: 'userId',\n      foreignField: '_id',\n      as: 'user'\n  }},\n  { $unwind: '$user' },\n  { $group: {\n      _id: '$user.country',\n      totalRevenue: { $sum: '$total' },\n      orderCount: { $sum: 1 }\n  }},\n  { $sort: { totalRevenue: -1 } },\n  { $limit: 10 }\n]);\n```\n\n## Performance Best Practices\n- **Connection Pooling**: Reuse database connections\n- **Batch Operations**: Use bulkWrite for multiple operations\n- **Read Preference**: Use secondary reads when appropriate\n- **Write Concern**: Balance durability and performance\n- **Sharding**: Horizontal scaling for large datasets\n\n## Security Considerations\n- **Authentication**: Enable auth in production\n- **Authorization**: Use role-based access control\n- **Encryption**: Enable TLS/SSL\n- **Field Encryption**: Client-side field encryption for sensitive data\n- **Auditing**: Enable audit logs\n\n## Mongoose Best Practices\n```javascript\n// Schema definition with validation\nconst userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    unique: true,\n    lowercase: true,\n    validate: [validator.isEmail, 'Invalid email']\n  },\n  age: {\n    type: Number,\n    min: [18, 'Must be at least 18'],\n    max: [120, 'Must be at most 120']\n  },\n  roles: [{\n    type: String,\n    enum: ['user', 'admin', 'moderator']\n  }]\n}, {\n  timestamps: true,\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n});\n\n// Virtual properties\nuserSchema.virtual('fullName').get(function() {\n  return `${this.firstName} ${this.lastName}`;\n});\n\n// Indexes\nuserSchema.index({ email: 1, createdAt: -1 });\n\n// Middleware\nuserSchema.pre('save', async function(next) {\n  if (this.isModified('password')) {\n    this.password = await bcrypt.hash(this.password, 10);\n  }\n  next();\n});\n```\n\n## Monitoring and Maintenance\n- **Performance Monitoring**: Use MongoDB Atlas or Ops Manager\n- **Slow Query Logs**: Enable and analyze\n- **Index Usage**: Monitor and remove unused indexes\n- **Storage**: Monitor disk usage and plan capacity\n- **Backups**: Regular automated backups\n- **Replica Sets**: High availability setup",
    "tags": ["mongodb", "nosql", "database", "mongoose", "performance"],
    "author": "MongoDB Inc.",
    "detailedDescription": "Comprehensive MongoDB guidelines covering schema design, indexing strategies, query optimization, aggregation pipelines, security, and Mongoose ODM best practices for building scalable NoSQL applications."
  },
  {
    "id": "golang-development-rules",
    "name": "Go (Golang) Development Best Practices",
    "description": "Go programming patterns, idioms, and best practices for backend development",
    "type": "rule",
    "category": "backend",
    "platforms": ["cursor", "windsurf"],
    "featured": true,
    "content": "# Go Development Best Practices\n\n## Go Principles\n- **Simplicity**: Prefer simple, clear code over clever solutions\n- **Composition**: Favor composition over inheritance\n- **Interfaces**: Define small, focused interfaces\n- **Concurrency**: Use goroutines and channels effectively\n- **Error Handling**: Explicit error handling, no exceptions\n\n## Project Structure\n```\nproject/\n├── cmd/\n│   └── server/\n│       └── main.go\n├── internal/\n│   ├── handlers/\n│   ├── services/\n│   ├── models/\n│   └── repository/\n├── pkg/\n│   └── utils/\n├── configs/\n├── scripts/\n├── go.mod\n└── go.sum\n```\n\n## Code Style\n- **Formatting**: Use `gofmt` and `goimports`\n- **Linting**: Use `golangci-lint`\n- **Naming**: Follow Go naming conventions\n- **Comments**: Write clear godoc comments\n- **Package Names**: Short, lowercase, no underscores\n\n## Error Handling\n```go\n// Custom error types\ntype ValidationError struct {\n    Field string\n    Message string\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf(\"validation error: %s - %s\", e.Field, e.Message)\n}\n\n// Error wrapping\nif err != nil {\n    return fmt.Errorf(\"failed to process user: %w\", err)\n}\n\n// Error checking\nuser, err := getUserByID(id)\nif err != nil {\n    if errors.Is(err, ErrNotFound) {\n        return nil, status.Error(codes.NotFound, \"user not found\")\n    }\n    return nil, fmt.Errorf(\"get user: %w\", err)\n}\n```\n\n## Interfaces and Types\n```go\n// Small, focused interfaces\ntype Reader interface {\n    Read(ctx context.Context, id string) (*Entity, error)\n}\n\ntype Writer interface {\n    Write(ctx context.Context, entity *Entity) error\n}\n\n// Embed interfaces for composition\ntype Repository interface {\n    Reader\n    Writer\n}\n\n// Accept interfaces, return concrete types\nfunc NewService(repo Repository) *Service {\n    return &Service{repo: repo}\n}\n```\n\n## Concurrency Patterns\n```go\n// Goroutine with error handling\nerrCh := make(chan error, 1)\ngo func() {\n    errCh <- doSomeWork()\n}()\n\nselect {\ncase err := <-errCh:\n    if err != nil {\n        return fmt.Errorf(\"work failed: %w\", err)\n    }\ncase <-ctx.Done():\n    return ctx.Err()\n}\n\n// Worker pool pattern\ntype Job struct {\n    ID   int\n    Data string\n}\n\nfunc workerPool(jobs <-chan Job, results chan<- Result, workerCount int) {\n    var wg sync.WaitGroup\n    wg.Add(workerCount)\n    \n    for i := 0; i < workerCount; i++ {\n        go func() {\n            defer wg.Done()\n            for job := range jobs {\n                result := processJob(job)\n                results <- result\n            }\n        }()\n    }\n    \n    wg.Wait()\n    close(results)\n}\n```\n\n## HTTP Server\n```go\n// Using chi router\nfunc setupRoutes() chi.Router {\n    r := chi.NewRouter()\n    \n    // Middleware\n    r.Use(middleware.Logger)\n    r.Use(middleware.Recoverer)\n    r.Use(middleware.Timeout(60 * time.Second))\n    \n    // Routes\n    r.Route(\"/api/v1\", func(r chi.Router) {\n        r.Use(authMiddleware)\n        r.Get(\"/users/{id}\", handleGetUser)\n        r.Post(\"/users\", handleCreateUser)\n    })\n    \n    return r\n}\n\n// Handler with proper error handling\nfunc handleGetUser(w http.ResponseWriter, r *http.Request) {\n    ctx := r.Context()\n    userID := chi.URLParam(r, \"id\")\n    \n    user, err := userService.GetByID(ctx, userID)\n    if err != nil {\n        handleError(w, err)\n        return\n    }\n    \n    respond(w, http.StatusOK, user)\n}\n```\n\n## Database Patterns\n```go\n// Using database/sql\ntype UserRepository struct {\n    db *sql.DB\n}\n\nfunc (r *UserRepository) GetByID(ctx context.Context, id string) (*User, error) {\n    var user User\n    query := `SELECT id, name, email FROM users WHERE id = $1`\n    \n    err := r.db.QueryRowContext(ctx, query, id).Scan(\n        &user.ID, &user.Name, &user.Email,\n    )\n    if err == sql.ErrNoRows {\n        return nil, ErrNotFound\n    }\n    if err != nil {\n        return nil, fmt.Errorf(\"query user: %w\", err)\n    }\n    \n    return &user, nil\n}\n\n// Transaction handling\nfunc (r *UserRepository) CreateWithProfile(ctx context.Context, user *User, profile *Profile) error {\n    tx, err := r.db.BeginTx(ctx, nil)\n    if err != nil {\n        return fmt.Errorf(\"begin transaction: %w\", err)\n    }\n    defer tx.Rollback()\n    \n    if err := createUser(ctx, tx, user); err != nil {\n        return fmt.Errorf(\"create user: %w\", err)\n    }\n    \n    if err := createProfile(ctx, tx, profile); err != nil {\n        return fmt.Errorf(\"create profile: %w\", err)\n    }\n    \n    return tx.Commit()\n}\n```\n\n## Testing\n```go\n// Table-driven tests\nfunc TestValidateEmail(t *testing.T) {\n    tests := []struct {\n        name    string\n        email   string\n        wantErr bool\n    }{\n        {\"valid email\", \"test@example.com\", false},\n        {\"invalid email\", \"invalid\", true},\n        {\"empty email\", \"\", true},\n    }\n    \n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            err := ValidateEmail(tt.email)\n            if (err != nil) != tt.wantErr {\n                t.Errorf(\"ValidateEmail() error = %v, wantErr %v\", err, tt.wantErr)\n            }\n        })\n    }\n}\n\n// Mocking interfaces\ntype mockRepository struct {\n    users map[string]*User\n}\n\nfunc (m *mockRepository) GetByID(ctx context.Context, id string) (*User, error) {\n    user, ok := m.users[id]\n    if !ok {\n        return nil, ErrNotFound\n    }\n    return user, nil\n}\n```\n\n## Performance Tips\n- **Profiling**: Use pprof for CPU and memory profiling\n- **Benchmarking**: Write benchmarks for critical paths\n- **Pooling**: Reuse objects with sync.Pool\n- **Buffering**: Use buffered channels appropriately\n- **Avoid Allocations**: Minimize allocations in hot paths",
    "tags": ["golang", "go", "concurrency", "backend", "performance"],
    "author": "Go Community",
    "detailedDescription": "Comprehensive Go development guidelines covering language idioms, project structure, error handling, concurrency patterns, HTTP servers, database integration, testing strategies, and performance optimization."
  }
]
